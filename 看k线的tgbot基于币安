from telethon import TelegramClient, events, Button
from binance.client import Client
import mplfinance as mpf
import pandas as pd
import matplotlib.pyplot as plt
import os
from dotenv import load_dotenv
import numpy as np
from datetime import datetime, timedelta
from collections import defaultdict
import time

# åŠ è½½ç¯å¢ƒå˜é‡
load_dotenv()

# Telegram API é…ç½®
API_ID = os.getenv('API_ID')
API_HASH = os.getenv('API_HASH')
BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN')

# Binance API é…ç½®
BINANCE_API_KEY = os.getenv('BINANCE_API_KEY')
BINANCE_API_SECRET = os.getenv('BINANCE_API_SECRET')

# åˆ›å»ºå®¢æˆ·ç«¯
client = TelegramClient('kline_bot', API_ID, API_HASH).start(bot_token=BOT_TOKEN)
binance_client = Client(BINANCE_API_KEY, BINANCE_API_SECRET)

# åœ¨æ–‡ä»¶å¼€å¤´æ·»åŠ æ—¶é—´å‘¨æœŸå¸¸é‡
TIME_FRAMES = {
    '1m': Client.KLINE_INTERVAL_1MINUTE,
    '5m': Client.KLINE_INTERVAL_5MINUTE,
    '15m': Client.KLINE_INTERVAL_15MINUTE,
    '1h': Client.KLINE_INTERVAL_1HOUR,
    '4h': Client.KLINE_INTERVAL_4HOUR,
    '1d': Client.KLINE_INTERVAL_1DAY
}

# æŸ¥è¯¢é—´éš”é™åˆ¶é…ç½®
COOLDOWN_TIME = 3  # å†·å´æ—¶é—´ï¼ˆç§’ï¼‰
user_last_query = defaultdict(float)  # è®°å½•ç”¨æˆ·æœ€åæŸ¥è¯¢æ—¶é—´

async def get_valid_symbol(symbol):
    """éªŒè¯å¹¶è¿”å›æœ‰æ•ˆçš„äº¤æ˜“å¯¹åç§°"""
    symbol = symbol.upper()
    if not symbol.endswith('USDT'):
        symbol += 'USDT'
    
    try:
        info = await client.loop.run_in_executor(
            None, binance_client.get_exchange_info
        )
        valid_symbols = [s['symbol'] for s in info['symbols']]
        
        if symbol not in valid_symbols:
            return None
        return symbol
    except Exception as e:
        print(f"Error checking symbol: {e}")
        return None

async def generate_kline_chart(symbol, interval=Client.KLINE_INTERVAL_15MINUTE):
    """ç”ŸæˆæŒ‡å®šäº¤æ˜“å¯¹çš„Kçº¿å›¾"""
    try:
        # è·å–Kçº¿æ•°æ®
        klines = await client.loop.run_in_executor(
            None,
            lambda: binance_client.get_klines(symbol=symbol, interval=interval, limit=50)
        )

        # åˆ›å»º DataFrame
        data = pd.DataFrame(klines, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume', 
                                           'close_time', 'quote_asset_volume', 'number_of_trades',
                                           'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'ignore'])
        
        # è½¬æ¢æ•°æ®ç±»å‹
        data['timestamp'] = pd.to_datetime(data['timestamp'], unit='ms')
        # è½¬æ¢ä¸ºåŒ—äº¬æ—¶é—´ (UTC+8)
        data['timestamp'] = data['timestamp'] + pd.Timedelta(hours=8)
        for col in ['open', 'high', 'low', 'close', 'volume']:
            data[col] = data[col].astype(float)

        data.set_index('timestamp', inplace=True)

        # è®¾ç½®å›¾è¡¨æ ·å¼
        mc = mpf.make_marketcolors(
            up='#26a69a',
            down='#ef5350',
            edge='inherit',
            wick='#666666',
            volume='in',
            ohlc='inherit'
        )
        
        s = mpf.make_mpf_style(
            marketcolors=mc,
            gridstyle=':',
            y_on_right=True,
            facecolor='white',
            edgecolor='#f0f0f0',
            gridcolor='#f6f6f6',
            rc={
                'axes.labelsize': 9,
                'axes.titlesize': 12,
                'xtick.labelsize': 8,
                'ytick.labelsize': 8,
                'grid.alpha': 0.1,
                'axes.grid': True,
                'axes.grid.axis': 'y',
                'axes.edgecolor': '#e0e0e0',
                'axes.linewidth': 0.5,
                'patch.linewidth': 1.0,
                'lines.linewidth': 1.5
            }
        )

        # ç»˜åˆ¶Kçº¿å›¾
        fig, axes = mpf.plot(
            data,
            type='candle',
            title='',
            ylabel='',
            ylabel_lower='',
            volume=True,
            mav=(5, 10, 20),
            mavcolors=['#7986cb', '#64b5f6', '#90a4ae'],
            style=s,
            figsize=(16, 9),
            returnfig=True,
            panel_ratios=(8, 1),
            tight_layout=False,
            scale_padding={'left': 0.1, 'right': 1.5, 'top': 0.5, 'bottom': 0.1},
            volume_alpha=0.3
        )

        # è°ƒæ•´å­å›¾ä¹‹é—´çš„é—´è·
        plt.subplots_adjust(
            left=0.05,      # å·¦è¾¹è·
            right=0.95,     # å³è¾¹è·
            top=0.95,       # ä¸Šè¾¹è·
            bottom=0.1,     # åº•éƒ¨è¾¹è·
            hspace=0.0001   # æå°çš„é—´è·
        )

        # ä¸ºKçº¿å›¾æ·»åŠ æ—¶é—´è½´
        ax_time = axes[0].twiny()  # åˆ›å»ºä¸€ä¸ªå…±äº«yè½´çš„æ–°xè½´
        ax_time.set_xlim(axes[0].get_xlim())
        
        # è®¡ç®—åˆé€‚çš„æ—¶é—´åˆ»åº¦
        num_ticks = 5  # æ”¹ä¸º5ä¸ªæ—¶é—´ç‚¹
        tick_positions = np.linspace(0, len(data)-1, num_ticks, dtype=int)
        
        # è®¾ç½®åˆ»åº¦ä½ç½®å’Œæ ‡ç­¾
        ax_time.set_xticks(tick_positions)
        ax_time.set_xticklabels([data.index[i].strftime('%H:%M') for i in tick_positions])
        
        # è®¾ç½®æ—¶é—´è½´çš„æ ·å¼
        ax_time.spines['top'].set_visible(False)
        ax_time.spines['right'].set_visible(False)
        ax_time.spines['bottom'].set_position(('outward', 0))  # å°†æ—¶é—´è½´ç´§è´´Kçº¿å›¾åº•éƒ¨
        ax_time.tick_params(axis='x', colors='#666666', labelsize=8, length=2, pad=2)

        # éšè—æˆäº¤é‡å›¾çš„xè½´æ ‡ï¿½ï¿½
        axes[2].xaxis.set_visible(False)

        # è°ƒæ•´æˆäº¤é‡å›¾çš„é«˜åº¦å’Œä½ç½®
        box = axes[2].get_position()
        axes[2].set_position([box.x0, box.y0 + box.height * 0.3, box.width, box.height * 0.5])

        # ç§»é™¤åŸæ¥çš„xè½´æ ‡ç­¾
        axes[0].xaxis.set_visible(False)

        # è°ƒæ•´æ ‡é¢˜
        axes[0].set_title(f'{symbol}', fontsize=12, pad=10)
        
        # ç§»é™¤è½´æ ‡ç­¾
        axes[0].set_ylabel('')
        axes[2].set_ylabel('')

        # è®¾ç½®èƒŒæ™¯å’Œè¾¹æ¡†
        fig.patch.set_facecolor('white')
        for ax in axes:
            ax.set_facecolor('#ffffff')
            for spine in ax.spines.values():
                spine.set_color('#e0e0e0')
                spine.set_linewidth(0.5)
            ax.tick_params(colors='#666666', labelsize=8, length=2)
            ax.grid(True, linestyle=':', color='#f6f6f6', alpha=0.2)
            ax.spines['top'].set_visible(False)
            ax.spines['right'].set_visible(False)

        # è·å–ä»·æ ¼æ•°æ®
        last_price = data['close'].iloc[-1]
        open_price = data['open'].iloc[-1]
        high_price = data['high'].iloc[-1]
        low_price = data['low'].iloc[-1]
        price_change = ((last_price - data['close'].iloc[-2]) / data['close'].iloc[-2]) * 100
        
        # è®¡ç®—24å°æ—¶äº¤æ˜“é‡
        volume_24h = data['volume'].sum()
        
        # åœ¨å›¾è¡¨å³ä¸Šè§’æ·»åŠ æœ€æ–°ä»·æ ¼å’Œæ¶¨è·Œå¹…
        price_color = '#26a69a' if price_change >= 0 else '#ef5350'
        axes[0].text(0.98, 0.98,
                    f'${last_price:,.2f}\n{price_change:+.2f}%',
                    transform=axes[0].transAxes,
                    color=price_color,
                    fontsize=12,
                    ha='right',
                    va='top',
                    bbox=dict(facecolor='white',
                            edgecolor='none',
                            alpha=0.8,
                            pad=5))

        # æ·»åŠ ä»·æ ¼ä¿¡æ¯æ–‡æœ¬æ¡†
        info_text = (
            f'Last: ${last_price:,.2f}  24h Change: {price_change:+.2f}%\n'
            f'Open: ${open_price:,.2f}  High: ${high_price:,.2f}\n'
            f'Close: ${last_price:,.2f}  Low: ${low_price:,.2f}\n'
            f'24h Volume: {volume_24h:,.0f} USDT'
        )
        
        # åœ¨å›¾è¡¨åº•éƒ¨æ·»åŠ æ–‡æœ¬æ¡†
        fig.text(0.01, 0.02, 
                info_text,
                fontsize=9,
                color='#666666',
                bbox=dict(facecolor='white',
                         edgecolor='#e0e0e0',
                         alpha=0.8,
                         pad=10,
                         boxstyle='round'))

        # è°ƒæ•´å›¾è¡¨ï¿½ï¿½å±€ä»¥ç•™å‡ºç©ºé—´
        plt.subplots_adjust(bottom=0.15)

        # ä¿å­˜å›¾ç‰‡
        filename = f'{symbol.lower()}_chart.png'
        plt.savefig(filename, 
                    dpi=300, 
                    bbox_inches='tight',
                    facecolor='white',
                    edgecolor='none',
                    pad_inches=0.2,
                    transparent=False)
        plt.close()

        # è®¡ç®—æ›´å¤šæŠ€æœ¯æŒ‡æ ‡
        # è®¡ç®—RSI
        delta = data['close'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs)).iloc[-1]

        # è®¡ç®—24å°æ—¶ä»·æ ¼å˜åŒ–
        price_24h_change = ((last_price - data['close'].iloc[0]) / data['close'].iloc[0]) * 100
        
        # è·å–ä¹°å–è®¢å•ç°¿æ·±åº¦
        depth = await client.loop.run_in_executor(
            None,
            lambda: binance_client.get_order_book(symbol=symbol, limit=5)
        )
        
        # è®¡ç®—ä¹°å–å‹åŠ›
        buy_pressure = sum(float(bid[1]) for bid in depth['bids'][:5])
        sell_pressure = sum(float(ask[1]) for ask in depth['asks'][:5])
        pressure_ratio = (buy_pressure / sell_pressure) if sell_pressure > 0 else 1

        # è®¡ç®—æˆäº¤é‡å˜åŒ–
        vol_change = ((data['volume'].iloc[-1] - data['volume'].iloc[-2]) / data['volume'].iloc[-2]) * 100

        # è¿”å›æ‰©å±•çš„ä»·æ ¼æ•°æ®
        price_data = {
            'last_price': last_price,
            'price_change': price_change,
            'price_24h_change': price_24h_change,
            'open_price': open_price,
            'high_price': high_price,
            'low_price': low_price,
            'volume_24h': volume_24h,
            'rsi': rsi,
            'buy_pressure': buy_pressure,
            'sell_pressure': sell_pressure,
            'pressure_ratio': pressure_ratio,
            'vol_change': vol_change,
            'best_bid': float(depth['bids'][0][0]),
            'best_ask': float(depth['asks'][0][0]),
            'spread': float(depth['asks'][0][0]) - float(depth['bids'][0][0])
        }
        return filename, price_data

    except Exception as e:
        print(f"Error generating chart for {symbol}: {e}")
        return None

@client.on(events.NewMessage(pattern=r'^[a-zA-Z]+$'))
async def handle_message(event):
    """å¤„ç†ç”¨æˆ·æ¶ˆæ¯"""
    try:
        # æ£€æŸ¥ç”¨æˆ·æŸ¥è¯¢é—´éš”
        current_time = time.time()
        if current_time - user_last_query[event.sender_id] < COOLDOWN_TIME:
            remaining = round(COOLDOWN_TIME - (current_time - user_last_query[event.sender_id]), 1)
            await event.reply(f"â³ è¯·ç­‰å¾… {remaining} ç§’åå†æ¬¡æŸ¥è¯¢")
            return
            
        # æ›´æ–°æœ€åæŸ¥è¯¢æ—¶é—´
        user_last_query[event.sender_id] = current_time
        
        # å‘é€ç­‰å¾…æ¶ˆæ¯
        wait_msg = await event.reply("æ­£åœ¨ç”Ÿæˆå›¾è¡¨ï¼Œè¯·ç¨å€™...")
        
        # è·å–å¹¶éªŒè¯äº¤æ˜“å¯¹
        symbol = event.text.strip().upper()
        if not symbol.endswith('USDT'):
            symbol += 'USDT'

        # ç”Ÿæˆå›¾è¡¨å’Œè·å–æ•°æ®
        result = await generate_kline_chart(symbol)
        if not result:
            await wait_msg.edit("ç”Ÿæˆå›¾è¡¨å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚")
            return

        chart_file, price_data = result  # ç°åœ¨ä½¿ç”¨ price_data

        # æ„å»ºç®€çŸ­çš„ä»·æ ¼ä¿¡æ¯
        price_emoji = "ğŸŸ¢" if price_data['price_change'] >= 0 else "ğŸ”´"
        change_arrow = "â†—ï¸" if price_data['price_change'] >= 0 else "â†˜ï¸"
        
        # æ ¹æ®ä»·æ ¼å¤§å°åŠ¨æ€è°ƒæ•´æ˜¾ç¤ºç²¾åº¦
        def format_price(price):
            if price >= 1:
                return f"${price:,.2f}"
            elif price >= 0.0001:
                return f"${price:.6f}"
            else:
                return f"${price:.8f}"

        # æ„å»ºç®€çŸ­çš„çŠ¶æ€æ¶ˆæ¯
        caption = (
            f"{symbol} {price_emoji}\n"
            f"ä»·æ ¼: {format_price(price_data['last_price'])} {change_arrow}\n"
            f"24h: {price_data['price_change']:+.2f}%\n"
            f"æˆäº¤é‡: {price_data['volume_24h']:,.0f} USDT"
        )

        # åˆ›å»ºæ—¶é—´å‘¨æœŸå’Œè¯¦ç»†æ•°æ®æŒ‰é’®
        buttons = [
            [
                Button.inline("1m", f"timeframe_{symbol}_1m"),
                Button.inline("5m", f"timeframe_{symbol}_5m"),
                Button.inline("15m âœ“", f"timeframe_{symbol}_15m"),
            ],
            [
                Button.inline("1h", f"timeframe_{symbol}_1h"),
                Button.inline("4h", f"timeframe_{symbol}_4h"),
                Button.inline("1d", f"timeframe_{symbol}_1d"),
            ],
            [
                Button.inline("æŸ¥çœ‹è¯¦ç»†æ•°æ®", f"details_{symbol}")
            ]
        ]

        # å‘é€å›¾è¡¨ã€ç®€çŸ­ä¿¡æ¯å’ŒæŒ‰é’®
        await event.reply(caption, file=chart_file, buttons=buttons)
        await wait_msg.delete()
        
        # åˆ é™¤å›¾è¡¨æ–‡ä»¶
        os.remove(chart_file)

    except Exception as e:
        await event.reply(f"å‘ç”Ÿé”™è¯¯: {str(e)}")

# æ·»åŠ è¯¦ç»†æ•°æ®æŒ‰é’®çš„å›è°ƒå¤„ç†
@client.on(events.CallbackQuery(pattern=r"details_(.+)"))
async def handle_details(event):
    try:
        # æ£€æŸ¥ç”¨æˆ·æŸ¥è¯¢é—´éš”
        current_time = time.time()
        if current_time - user_last_query[event.sender_id] < COOLDOWN_TIME:
            remaining = round(COOLDOWN_TIME - (current_time - user_last_query[event.sender_id]), 1)
            await event.answer(f"â³ è¯·ç­‰å¾… {remaining} ç§’åå†æŸ¥è¯¢", alert=True)
            return
            
        # æ›´æ–°æœ€åæŸ¥è¯¢æ—¶é—´
        user_last_query[event.sender_id] = current_time
        
        # è·å–äº¤æ˜“å¯¹å¹¶å¤„ç†å­—èŠ‚å­—ç¬¦ä¸²
        symbol = event.pattern_match.group(1)
        if isinstance(symbol, bytes):
            symbol = symbol.decode()
        
        # ç§»é™¤å¯èƒ½çš„ b'' æ ‡è®°
        if symbol.startswith("b'") and symbol.endswith("'"):
            symbol = symbol[2:-1]
        
        # ç”Ÿæˆå›¾è¡¨å’Œè·å–æ•°æ®
        result = await generate_kline_chart(symbol)
        if not result:
            await event.answer("è·å–æ•°æ®å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚", alert=True)
            return

        _, price_data = result

        # æ„å»ºè¯¦ç»†æ•°æ®æ¶ˆæ¯
        price_emoji = "ğŸŸ¢" if price_data['price_change'] >= 0 else "ğŸ”´"
        change_arrow = "â†—ï¸" if price_data['price_change'] >= 0 else "â†˜ï¸"
        
        # è®¡ç®—é¢å¤–æ•°æ®
        price_range = price_data['high_price'] - price_data['low_price']
        range_percent = (price_range / price_data['low_price']) * 100
        avg_price = (price_data['high_price'] + price_data['low_price']) / 2
        price_change = price_data['price_change']
        
        # è·å–åŒ—äº¬æ—¶é—´
        beijing_time = (datetime.now() + timedelta(hours=8)).strftime('%Y-%m-%d %H:%M:%S')
        
        # æ ¹æ®ä»·æ ¼å¤§å°åŠ¨æ€è°ƒæ•´æ˜¾ç¤ºç²¾åº¦
        def format_price(price):
            if price >= 1:
                return f"${price:,.2f}"
            elif price >= 0.0001:
                return f"${price:.6f}"
            else:
                return f"${price:.8f}"
        
        message = (
            f"ğŸ“Š {symbol} å¸‚åœºè¡Œæƒ…\n\n"
            f"{price_emoji} å½“å‰ä»·æ ¼: {format_price(price_data['last_price'])} {change_arrow}\n"
            f"â”œ 24hæ¶¨è·Œ: {price_data['price_change']:+.2f}%\n"
            f"â”” æ•´ä½“æ¶¨è·Œ: {price_data['price_24h_change']:+.2f}%\n\n"
            f"ğŸ“ˆ ä»·æ ¼åŒºé—´\n"
            f"â”œ æœ€é«˜ä»·: {format_price(price_data['high_price'])}\n"
            f"â”œ æœ€ä½ä»·: {format_price(price_data['low_price'])}\n"
            f"â”œ æ³¢åŠ¨å€¼: {format_price(price_range)} ({range_percent:.1f}%)\n"
            f"â”” å‡ä»·: {format_price(avg_price)}\n\n"
            f"ğŸ“Š äº¤æ˜“ä¿¡æ¯\n"
            f"â”œ å¼€ç›˜ä»·: {format_price(price_data['open_price'])}\n"
            f"â”œ æˆäº¤é‡: {price_data['volume_24h']:,.0f} USDT\n"
            f"â”œ é‡æ¯”å˜åŒ–: {price_data['vol_change']:+.1f}%\n"
            f"â”” çŠ¶æ€: {'æ´»è·ƒ' if price_data['volume_24h'] > 0 else 'ä¸æ´»è·ƒ'}\n\n"
            f"ğŸ“— ä¹°å–æŒ‚å•\n"
            f"â”œ æœ€ä½³ä¹°ä»·: {format_price(price_data['best_bid'])}\n"
            f"â”œ æœ€ä½³å–ä»·: {format_price(price_data['best_ask'])}\n"
            f"â”œ ä¹°å–å·®ä»·: {format_price(price_data['spread'])}\n"
            f"â”” ä¹°å–æ¯”ä¾‹: {price_data['pressure_ratio']:,.2f}\n\n"
            f"ğŸ“‰ æŠ€æœ¯æŒ‡æ ‡\n"
            f"â”œ RSI(14): {price_data['rsi']:.1f}\n"
            f"â”œ è·æœ€é«˜: {((price_data['high_price'] - price_data['last_price']) / price_data['high_price'] * 100):,.1f}%\n"
            f"â”œ è·æœ€ä½: {((price_data['last_price'] - price_data['low_price']) / price_data['low_price'] * 100):+,.1f}%\n"
            f"â”” æ³¢åŠ¨ç‡: {range_percent:.1f}%\n\n"
            f"ğŸ•’ å¸‚åœºæƒ…ç»ª\n"
            f"â”œ RSIæŒ‡ç¤º: {'è¶…ä¹°' if price_data['rsi'] > 70 else 'è¶…å–' if price_data['rsi'] < 30 else 'ä¸­æ€§'}\n"
            f"â”œ é‡ä»·å…³ç³»: {'é‡ä»·é½å‡' if price_data['vol_change'] > 0 and price_change > 0 else 'é‡ä»·é½è·Œ' if price_data['vol_change'] < 0 and price_change < 0 else 'èƒŒç¦»'}\n"
            f"â”” ä¹°å–å‹åŠ›: {'ä¹°æ–¹å ä¼˜' if price_data['pressure_ratio'] > 1.2 else 'å–æ–¹å ä¼˜' if price_data['pressure_ratio'] < 0.8 else 'å¹³è¡¡'}"
        )

        # å‘é€è¯¦ç»†æ•°æ®æ¶ˆæ¯
        await event.answer()  # æ¸…é™¤åŠ è½½çŠ¶æ€
        await event.respond(message)

    except Exception as e:
        await event.answer(f"å‘ç”Ÿé”™è¯¯: {str(e)}", alert=True)

# æ·»åŠ æŒ‰é’®å›è°ƒå¤„ç†å‡½æ•°
@client.on(events.CallbackQuery(pattern=r"timeframe_(.+)_(.+)"))
async def handle_timeframe_change(event):
    try:
        # æ£€æŸ¥ç”¨æˆ·æŸ¥è¯¢é—´éš”
        current_time = time.time()
        if current_time - user_last_query[event.sender_id] < COOLDOWN_TIME:
            remaining = round(COOLDOWN_TIME - (current_time - user_last_query[event.sender_id]), 1)
            await event.answer(f"â³ è¯·ç­‰å¾… {remaining} ç§’åå†æ“ä½œ", alert=True)
            return
            
        # æ›´æ–°æœ€åæŸ¥è¯¢æ—¶é—´
        user_last_query[event.sender_id] = current_time
        
        # è§£æå›è°ƒæ•°æ®å¹¶å¤„ç†å­—èŠ‚å­—ç¬¦ä¸²
        symbol, timeframe = event.pattern_match.groups()
        if isinstance(symbol, bytes):
            symbol = symbol.decode()
        if isinstance(timeframe, bytes):
            timeframe = timeframe.decode()
            
        # ç§»é™¤å¯èƒ½çš„ b'' æ ‡è®°
        if symbol.startswith("b'") and symbol.endswith("'"):
            symbol = symbol[2:-1]
        
        # å‘é€ç­‰å¾…æ¶ˆæ¯
        await event.answer(f"æ­£åœ¨åˆ‡æ¢åˆ°{timeframe}å‘¨æœŸ...")
        
        # ç”Ÿæˆæ–°çš„å›¾è¡¨
        result = await generate_kline_chart(symbol, TIME_FRAMES[timeframe])
        if not result:
            await event.answer("ç”Ÿæˆå›¾è¡¨å¤±è´¥ï¼Œè¯·é‡è¯•ã€‚", alert=True)
            return

        chart_file, _ = result

        # æ›´æ–°æŒ‰é’®çŠ¶æ€
        buttons = [
            [
                Button.inline("1m âœ“" if timeframe == "1m" else "1m", f"timeframe_{symbol}_1m"),
                Button.inline("5m âœ“" if timeframe == "5m" else "5m", f"timeframe_{symbol}_5m"),
                Button.inline("15m âœ“" if timeframe == "15m" else "15m", f"timeframe_{symbol}_15m"),
            ],
            [
                Button.inline("1h âœ“" if timeframe == "1h" else "1h", f"timeframe_{symbol}_1h"),
                Button.inline("4h âœ“" if timeframe == "4h" else "4h", f"timeframe_{symbol}_4h"),
                Button.inline("1d âœ“" if timeframe == "1d" else "1d", f"timeframe_{symbol}_1d"),
            ],
            [
                Button.inline("æŸ¥çœ‹è¯¦ç»†æ•°æ®", f"details_{symbol}")
            ]
        ]

        # æ›´æ–°æ¶ˆæ¯
        message = await event.get_message()
        await message.edit(file=chart_file, buttons=buttons)
        
        # åˆ é™¤å›¾è¡¨æ–‡ä»¶
        os.remove(chart_file)

    except Exception as e:
        print(f"Error in timeframe change: {e}")  # æ·»åŠ é”™è¯¯æ—¥å¿—
        await event.answer(f"å‘ç”Ÿé”™è¯¯: {str(e)}", alert=True)

@client.on(events.NewMessage(pattern='/start'))
async def start(event):
    """å¤„ç† /start å‘½ä»¤"""
    await event.reply(
        "æ¬¢è¿ä½¿ç”¨ K çº¿å›¾æœºå™¨äººï¼\n\n"
        "ç›´æ¥å‘é€ä»»æ„å¸ç§ç¬¦å·ï¼Œå³å¯è·å–è¯¥å¸çš„å®æ—¶ K çº¿å›¾ã€‚\n"
        "å¦‚ï¼š<code>BTC</code>ã€<code>ETH</code>ã€<code>SOL</code>ã€<code>PEPE</code>ï¼ˆå¤§å°å†™å‡å¯ï¼‰â€¦â€¦\n\n"
        "æ”¯æŒæ‰€æœ‰å¸å®‰ç°è´§äº¤æ˜“å¯¹ã€‚"
        "<a href='https://t.me/zouxin77'>\nå¦‚æœé‡åˆ°é—®é¢˜æˆ–æœ‰ä»»ä½•ç–‘é—®ï¼Œç‚¹å‡»è”ç³»æˆ‘ä»¬</a>\n\n"  # ä½¿ç”¨ HTML æ ¼å¼çš„é“¾æ¥
        ,
        parse_mode='html',
        link_preview=False
    )

def main():
    """å¯åŠ¨æœºå™¨äºº"""
    print("æœºå™¨äººå·²å¯åŠ¨...")
    client.run_until_disconnected()

if __name__ == '__main__':
    main()
