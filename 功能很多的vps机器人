from telethon import TelegramClient, events, Button
import psutil
import os
import asyncio
from datetime import datetime
import pathlib
from typing import Dict
import subprocess
import json

# é…ç½®ä¿¡æ¯
API_ID = 21332425
API_HASH = 'f5d0cddc784e3a7a09ea9714ed01f238'
BOT_TOKEN = '7258082736:AAEof4V0c7vGL5ZlOboQ-PKjZCuftB4Dzag'

# å…è®¸ä½¿ç”¨æœºå™¨äººçš„ç”¨æˆ·IDåˆ—è¡¨
ALLOWED_USERS = [5179399961,6279591488]

# æ·»åŠ çŠ¶æ€ç®¡ç†
class UserState:
    def __init__(self):
        self.waiting_mkdir = False
        self.waiting_mkfile = False  # æ·»åŠ åˆ›å»ºæ–‡ä»¶çŠ¶æ€
        self.waiting_edit = False
        self.waiting_proxy = False  # æ·»åŠ åä»£çŠ¶æ€
        self.proxy_step = None  # è®°å½•åä»£é…ç½®æ­¥éª¤
        self.proxy_data = {}  # å­˜å‚¨åä»£é…ç½®æ•°æ®
        self.current_path = None
        self.edit_file_path = None  # ç”¨äºå­˜å‚¨æ­£åœ¨ç¼–è¾‘çš„æ–‡ä»¶è·¯å¾„
        self.docker_operation = None  # è®°å½•å½“å‰çš„ docker æ“ä½œ

# åœ¨å…¨å±€å˜é‡éƒ¨åˆ†æ·»åŠ 
user_states: Dict[int, UserState] = {}

# åˆå§‹åŒ–æœºå™¨äºº
bot = TelegramClient('bot_session', API_ID, API_HASH).start(bot_token=BOT_TOKEN)

async def refresh_directory_view(event, current_path):
    """åˆ·æ–°ç›®å½•è§†å›¾çš„è¾…åŠ©å‡½æ•°"""
    try:
        buttons = []
        path_obj = pathlib.Path(current_path)
        items = list(path_obj.iterdir())
        
        # åˆ†ç±»æ–‡ä»¶å’Œç›®å½•
        directories = [item for item in items if item.is_dir()]
        files = [item for item in items if item.is_file()]
        
        # é™åˆ¶æ˜¾ç¤ºæ•°é‡
        MAX_ITEMS = 30  # æ¯é¡µæœ€å¤šæ˜¾ç¤º30ä¸ªé¡¹ç›®
        total_dirs = len(directories)
        total_files = len(files)
        
        if total_dirs + total_files > MAX_ITEMS:
            # æ·»åŠ æç¤ºä¿¡æ¯
            buttons.append([Button.inline(f'âš ï¸ ç›®å½•å†…å®¹è¿‡å¤š (å…±{total_dirs}ä¸ªç›®å½•, {total_files}ä¸ªæ–‡ä»¶)', 'noop')])
            # åªæ˜¾ç¤ºå‰15ä¸ªç›®å½•å’Œå‰15ä¸ªæ–‡ä»¶
            directories = directories[:15]
            files = files[:15]
        
        # æ·»åŠ ç›®å½•æŒ‰é’®
        dir_buttons = []
        for directory in directories:
            dir_buttons.append(Button.inline(f'ğŸ“ {directory.name}', f'cd:{directory}'))
            if len(dir_buttons) == 3:
                buttons.append(dir_buttons)
                dir_buttons = []
        if dir_buttons:
            buttons.append(dir_buttons)
        
        # æ·»åŠ æ–‡ä»¶æŒ‰é’® 
        file_buttons = []
        for file in files:
            file_buttons.append(Button.inline(f'ğŸ“„ {file.name}', f'file:{file}'))
            if len(file_buttons) == 3:
                buttons.append(file_buttons)
                file_buttons = []
        if file_buttons:
            buttons.append(file_buttons)
        
        # æ·»åŠ åˆ†å‰²çº¿
        buttons.append([Button.inline('  â”€â”€â”€ â”€â”€â”€æ“ä½œèœå• â”€â”€â”€ â”€â”€â”€ ', 'noop')])
        
        # åªåœ¨æ ¹ç›®å½•æ˜¾ç¤ºç³»ç»ŸçŠ¶æ€å’Œè¿›ç¨‹æŒ‰é’®
        if str(path_obj) == '/':
            system_buttons = [
                [Button.inline('ğŸ’¾ æŸ¥çœ‹ç£ç›˜ä½¿ç”¨æƒ…å†µ', 'disk')],
                [Button.inline('ğŸ”„ è¿è¡Œä¸­çš„ç¨‹åº', 'running_py')],
                [
                    Button.inline('ğŸŒ åå‘ä»£ç†', 'proxy'),
                    Button.inline('ğŸš€ å¿«é€Ÿæµ‹è¯•', 'quick_test')
                ],
                [Button.inline('ğŸ³ Dockerç®¡ç†', 'docker')],
                [Button.inline('âš¡ï¸ æœåŠ¡å™¨æµ‹é€Ÿ', 'speed_test')]
            ]
            buttons.extend(system_buttons)  # ä½¿ç”¨extendè€Œä¸æ˜¯appendæ¥æ·»åŠ å¤šè¡ŒæŒ‰é’®
        
        # æ·»åŠ æ“ä½œæŒ‰é’®
        operation_buttons = []
        # åªåœ¨éæ ¹ç›®å½•æ˜¾ç¤ºåˆ é™¤æ–‡ä»¶å¤¹æŒ‰é’®
        if str(path_obj) != '/':
            operation_buttons.append(Button.inline('ğŸ—‘ åˆ é™¤æ–‡ä»¶å¤¹', f'rmdir:{current_path}'))
        operation_buttons.append(Button.inline('â• åˆ›å»ºæ–‡ä»¶å¤¹', f'mkdir:{current_path}'))
        operation_buttons.append(Button.inline('ğŸ“ åˆ›å»ºæ–‡ä»¶', f'mkfile:{current_path}'))
        buttons.append(operation_buttons)
        
        # æ·»åŠ è¿”å›ä¸Šçº§æŒ‰é’®
        if str(path_obj) != '/':
            buttons.append([Button.inline('ğŸ“‚ ..', f'cd:{path_obj.parent}')])
            
        return buttons
        
    except Exception as e:
        print(f"ç”Ÿæˆç›®å½•è§†å›¾æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")
        raise

@bot.on(events.NewMessage(pattern='/start'))
async def start(event):
    """å¯åŠ¨å‘½ä»¤å¤„ç†å™¨"""
    if event.sender_id not in ALLOWED_USERS:
        await event.respond('æŠ±æ­‰ï¼Œæ‚¨æ²¡æœ‰ä½¿ç”¨æ­¤æœºå™¨äººçš„æƒé™ã€‚')
        return
    
    # ç›´æ¥æ˜¾ç¤ºæ–‡ä»¶æµè§ˆå™¨å†…å®¹ï¼Œä½¿ç”¨ edit=False
    await list_directory(event, path='/', edit=False)

@bot.on(events.CallbackQuery(pattern='disk'))
async def disk_usage(event):
    """è·å–ç£ç›˜ä½¿ç”¨æƒ…å†µ"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    cpu = psutil.cpu_percent()
    memory = psutil.virtual_memory()
    disk = psutil.disk_usage('/')
    uptime = datetime.now() - datetime.fromtimestamp(psutil.boot_time())
    
    status_msg = (
        f'ğŸ“Š æœåŠ¡å™¨çŠ¶æ€:\n\n'
        f'CPUä½¿ç”¨ç‡: {cpu}%\n'
        f'å†…å­˜ä½¿ç”¨: {memory.percent}%\n'
        f'ç£ç›˜ä½¿ç”¨: {disk.percent}%\n'
        f'è¿è¡Œæ—¶é—´: {uptime}'
    )
    
    # ä¿®æ”¹è¿”å›æŒ‰é’®ï¼Œç›´æ¥è¿”å›åˆ°æ–‡ä»¶æµè§ˆå™¨
    buttons = [[Button.inline('ğŸ“‚ è¿”å›æ–‡ä»¶æµè§ˆå™¨', 'ls')]]
    await event.edit(status_msg, buttons=buttons)

@bot.on(events.CallbackQuery(pattern='ls'))
async def list_directory(event, path=None, edit=True):
    """åˆ—å‡ºç›®å½•å†…å®¹"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    current_path = path or '/'
    
    try:
        buttons = await refresh_directory_view(event, current_path)
        if edit:
            await event.edit(f'ğŸ“‚ å½“å‰ç›®å½•: {current_path}', buttons=buttons)
        else:
            await event.respond(f'ğŸ“‚ å½“å‰ç›®å½•: {current_path}', buttons=buttons)
    except Exception as e:
        print(f"åˆ—å‡ºç›®å½•æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")
        if edit:
            await event.edit(f'âŒ é”™è¯¯: {str(e)}')
        else:
            await event.respond(f'âŒ é”™è¯¯: {str(e)}')

@bot.on(events.CallbackQuery(pattern=r'cd:(.+)'))
async def change_directory(event):
    """åˆ‡æ¢ç›®å½•"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    path = event.pattern_match.group(1).decode()
    try:
        if not pathlib.Path(path).exists():
            await event.answer('âŒ ç›®å½•ä¸å­˜åœ¨')
            return
        
        await list_directory(event, path=path)
        await event.answer()
    except Exception as e:
        print(f"åˆ‡æ¢ç›®å½•æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")
        await event.answer(f'âŒ é”™è¯¯: {str(e)}')

@bot.on(events.CallbackQuery(pattern=r'file:(.+)'))
async def file_info(event):
    """æ˜¾ç¤ºæ–‡ä»¶é€‰é¡¹"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    file_path = event.pattern_match.group(1).decode()
    path = pathlib.Path(file_path)
    
    try:
        buttons = [
            [
                Button.inline('ğŸ“ æŸ¥çœ‹æ–‡ä»¶ä¿¡æ¯', f'info:{file_path}'),
                Button.inline('ğŸ‘€ æŸ¥çœ‹æ–‡ä»¶å†…å®¹', f'view:{file_path}'),
                Button.inline('âœï¸ ç¼–è¾‘æ–‡ä»¶', f'edit:{file_path}')
            ],
            [Button.inline('ğŸ—‘ï¸ åˆ é™¤æ–‡ä»¶', f'rmfile:{file_path}')]
        ]
        
        # å¦‚æœæ˜¯ Python æ–‡ä»¶ï¼Œæ·»åŠ è¿è¡ŒæŒ‰é’®
        if path.suffix == '.py':
            buttons.append([Button.inline('â–¶ï¸ åœ¨åå°è¿è¡Œ', f'run:{file_path}')])
            
        buttons.append([Button.inline('ğŸš« å–æ¶ˆ', 'cancel')])
        
        await event.respond(
            f'ğŸ“„ æ–‡ä»¶: {path.name}\n'
            f'è¯·é€‰æ‹©æ“ä½œ:',
            buttons=buttons
        )
        await event.answer()
    except Exception as e:
        print(f"æ˜¾ç¤ºæ–‡ä»¶é€‰é¡¹æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")
        await event.answer(f'âŒ é”™è¯¯: {str(e)}', alert=True)

@bot.on(events.CallbackQuery(pattern=r'info:(.+)'))
async def show_file_info(event):
    """æ˜¾ç¤ºæ–‡ä»¶è¯¦ç»†ä¿¡æ¯"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    file_path = event.pattern_match.group(1).decode()
    try:
        path = pathlib.Path(file_path)
        stats = path.stat()
        
        info = (
            f'ğŸ“„ æ–‡ä»¶ä¿¡æ¯:\n\n'
            f'åç§°: {path.name}\n'
            f'å¤§å°: {stats.st_size / 1024:.2f} KB\n'
            f'åˆ›å»ºæ—¶é—´: {datetime.fromtimestamp(stats.st_birthtime)}\n'
            f'ä¿®æ”¹æ—¶é—´: {datetime.fromtimestamp(stats.st_mtime)}\n'
            f'æƒé™: {oct(stats.st_mode)[-3:]}'
        )
        await event.answer(info, alert=True)
    except Exception as e:
        print(f"è·å–æ–‡ä»¶ä¿¡æ¯æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")
        await event.answer(f'âŒ é”™è¯¯: {str(e)}', alert=True)

@bot.on(events.CallbackQuery(pattern=r'view:(.+)'))
async def view_file_content(event):
    """æŸ¥çœ‹æ–‡ä»¶å†…å®¹"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    file_path = event.pattern_match.group(1).decode()
    try:
        path = pathlib.Path(file_path)
        
        # æ£€æŸ¥æ–‡ä»¶å¤§å°
        if path.stat().st_size > 1024 * 1024:  # å¤§äº1MB
            await event.answer('âŒ æ–‡ä»¶å¤ªå¤§ï¼Œæ— æ³•æ˜¾ç¤ºå†…å®¹', alert=True)
            return
            
        # å°è¯•è¯»å–æ–‡ä»¶å†…å®¹
        try:
            content = path.read_text(encoding='utf-8')
            # å¦‚æœå†…å®¹å¤ªé•¿ï¼Œåªæ˜¾ç¤ºå‰2000ä¸ªå­—ç¬¦
            if len(content) > 2000:
                content = content[:2000] + '\n... (å†…å®¹å·²æˆªæ–­)'
        except UnicodeDecodeError:
            await event.answer('âŒ æ— æ³•è¯»å–æ–‡ä»¶å†…å®¹ï¼ˆå¯èƒ½æ˜¯äºŒè¿›åˆ¶æ–‡ä»¶ï¼‰', alert=True)
            return
            
        buttons = [[Button.inline('ğŸš« å–æ¶ˆ', 'cancel')]]
        await event.respond(  # æ”¹ç”¨ respond è€Œä¸æ˜¯ edit
            f'ğŸ“„ {path.name} çš„å†…å®¹:\n\n'
            f'```\n{content}\n```',
            buttons=buttons
        )
        await event.answer()
    except Exception as e:
        print(f"æŸ¥çœ‹æ–‡ä»¶å†…å®¹æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")
        await event.answer(f'âŒ é”™è¯¯: {str(e)}', alert=True)

# ä¿®æ”¹å–æ¶ˆæŒ‰é’®çš„å¤„ç†å‡½æ•°
@bot.on(events.CallbackQuery(pattern='cancel'))
async def cancel_operation(event):
    """å–æ¶ˆå½“å‰æ“ä½œ"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    try:
        # é‡ç½®ç”¨æˆ·çŠ¶æ€
        if event.sender_id in user_states:
            user_state = user_states[event.sender_id]
            # é‡ç½®æ‰€æœ‰çŠ¶æ€
            user_state.waiting_mkdir = False
            user_state.waiting_mkfile = False
            user_state.waiting_edit = False
            user_state.waiting_proxy = False  # æ·»åŠ åä»£çŠ¶æ€é‡ç½®
            user_state.proxy_step = None      # é‡ç½®åä»£æ­¥éª¤
            user_state.proxy_data = {}        # æ¸…ç©ºåä»£æ•°æ®
            user_state.current_path = None
            user_state.edit_file_path = None
        
        await event.delete()  # åˆ é™¤æ¶ˆæ¯
    except Exception as e:
        print(f"å–æ¶ˆæ“ä½œæ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")
        await event.answer(f'âŒ é”™è¯¯: {str(e)}', alert=True)

@bot.on(events.CallbackQuery(pattern='back'))
async def back_to_menu(event):
    """è¿”å›æ–‡ä»¶æµè§ˆå™¨"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    # ç›´æ¥è°ƒç”¨ list_directory æ˜¾ç¤ºæ–‡ä»¶æµè§ˆå™¨
    await list_directory(event, path='/')

# æ·»åŠ åˆ›å»ºæ–‡ä»¶å¤¹çš„å¤„ç†å‡½æ•°
@bot.on(events.CallbackQuery(pattern=r'mkdir:(.+)'))
async def mkdir_start(event):
    """å¼€å§‹åˆ›å»ºæ–‡ä»¶å¤¹æµç¨‹"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    path = event.pattern_match.group(1).decode()
    
    # ä¿å­˜ç”¨æˆ·çŠ¶æ€
    if event.sender_id not in user_states:
        user_states[event.sender_id] = UserState()
    user_states[event.sender_id].waiting_mkdir = True
    user_states[event.sender_id].current_path = path
    
    buttons = [[Button.inline('ğŸš« å–æ¶ˆ', 'cancel')]]
    await event.respond('è¯·è¾“å…¥æ–°æ–‡ä»¶å¤¹çš„åç§°:', buttons=buttons)
    await event.answer()

# å¤„ç†åå‘ä»£ç†é…ç½®çš„æ¶ˆæ¯
async def handle_proxy_message(event, user_state):
    """å¤„ç†åå‘ä»£ç†é…ç½®çš„æ¶ˆæ¯"""
    text = event.text.strip()
    
    if user_state.proxy_step == 'domain':
        if not text:
            await event.respond('âŒ åŸŸåä¸èƒ½ä¸ºç©ºï¼Œè¯·é‡æ–°è¾“å…¥:')
            return
        user_state.proxy_data['domain'] = text
        user_state.proxy_step = 'target_ip'
        await event.respond('è¯·è¾“å…¥ç›®æ ‡IP:')
        
    elif user_state.proxy_step == 'target_ip':
        if not text:
            await event.respond('âŒ ç›®æ ‡IPä¸èƒ½ä¸ºç©ºï¼Œè¯·é‡æ–°è¾“å…¥:')
            return
        user_state.proxy_data['target_ip'] = text
        user_state.proxy_step = 'target_port'
        await event.respond('è¯·è¾“å…¥ç›®æ ‡ç«¯å£:')
        
    elif user_state.proxy_step == 'target_port':
        await handle_proxy_config(event, user_state, text)

async def handle_proxy_config(event, user_state, port):
    """å¤„ç†åå‘ä»£ç†çš„é…ç½®"""
    if not port.isdigit():
        await event.respond('âŒ ç«¯å£å¿…é¡»æ˜¯æ•°å­—ï¼Œè¯·é‡æ–°è¾“å…¥:')
        return
        
    user_state.proxy_data['target_port'] = port
    
    try:
        await setup_proxy_config(event, user_state.proxy_data)
    except Exception as e:
        await event.respond(f'âŒ é…ç½®å¤±è´¥: {str(e)}')
    finally:
        # é‡ç½®çŠ¶æ€
        user_state.waiting_proxy = False
        user_state.proxy_step = None
        user_state.proxy_data = {}

async def setup_proxy_config(event, proxy_data):
    """è®¾ç½®åå‘ä»£ç†é…ç½®"""
    try:
        # æ£€æŸ¥ Docker æ˜¯å¦å·²å®‰è£…
        docker_check = subprocess.run(['which', 'docker'], capture_output=True, text=True)
        if not docker_check.stdout.strip():
            # Docker æœªå®‰è£…ï¼Œå°è¯•å®‰è£…
            await event.respond('æ­£åœ¨å®‰è£… Docker...')
            subprocess.run(['curl', '-fsSL', 'https://get.docker.com', '-o', 'get-docker.sh'])
            subprocess.run(['sh', 'get-docker.sh'])
            subprocess.run(['systemctl', 'start', 'docker'])
            subprocess.run(['systemctl', 'enable', 'docker'])
        
        # æ£€æŸ¥ nginx å®¹å™¨æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœå­˜åœ¨åˆ™åˆ é™¤é‡å»º
        nginx_check = subprocess.run(['docker', 'ps', '-a', '--filter', 'name=nginx'], capture_output=True, text=True)
        if 'nginx' in nginx_check.stdout:
            await event.respond('æ­£åœ¨é‡å»º Nginx å®¹å™¨...')
            subprocess.run(['docker', 'rm', '-f', 'nginx'])
        
        # åˆ›å»ºé…ç½®ç›®å½•
        os.makedirs('/home/web/conf.d', exist_ok=True)
        
        # åˆ›å»ºç®€å•çš„ HTTP é…ç½®
        config_content = f'''
server {{
    listen 80;
    listen [::]:80;
    server_name {proxy_data["domain"]};
    
    location / {{
        proxy_pass http://{proxy_data["target_ip"]}:{proxy_data["target_port"]};
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }}
}}
'''
        # å†™å…¥é…ç½®æ–‡ä»¶
        with open(f'/home/web/conf.d/{proxy_data["domain"]}.conf', 'w') as f:
            f.write(config_content)
        
        # åˆ›å»ºæ–°çš„ nginx å®¹å™¨
        await event.respond('æ­£åœ¨åˆ›å»º Nginx å®¹å™¨...')
        subprocess.run([
            'docker', 'run', '-d',
            '--name', 'nginx',
            '--restart', 'always',
            '-p', '80:80',
            '-v', '/home/web/conf.d:/etc/nginx/conf.d',
            'nginx'
        ])
        
        # ç­‰å¾…å®¹å™¨å¯åŠ¨
        await asyncio.sleep(2)
        
        # æ£€æŸ¥ nginx çŠ¶æ€
        nginx_logs = subprocess.run(['docker', 'logs', 'nginx'], capture_output=True, text=True)
        await event.respond(f"Nginx æ—¥å¿—:\n{nginx_logs.stdout}\n{nginx_logs.stderr}")
        
        # è·å–IPåœ°å€å¹¶å‘é€æˆåŠŸæ¶ˆæ¯
        await send_proxy_success_message(event, proxy_data)
        
        await event.respond(
            "âš ï¸ æ³¨æ„ï¼š\n"
            "1. å½“å‰ä»…é…ç½®äº† HTTP è®¿é—®\n"
            "2. å¦‚éœ€ HTTPSï¼Œè¯·æ‰‹åŠ¨é…ç½® SSL è¯ä¹¦\n"
            "3. å¦‚æœæ— æ³•è®¿é—®ï¼Œè¯·æ£€æŸ¥ï¼š\n"
            "   - åŸŸåè§£ææ˜¯å¦ç”Ÿæ•ˆ\n"
            "   - ç›®æ ‡æœåŠ¡å™¨æ˜¯å¦æ­£å¸¸è¿è¡Œ\n"
            "   - é˜²ç«å¢™æ˜¯å¦å…è®¸ 80 ç«¯å£è®¿é—®"
        )
        
    except Exception as e:
        raise Exception(f"é…ç½®å¤±è´¥: {str(e)}\nè¯·ç¡®ä¿ç³»ç»Ÿå·²å®‰è£… Docker å¹¶ä¸”æœ‰æƒé™æ‰§è¡Œ")

async def send_proxy_success_message(event, proxy_data):
    """å‘é€åå‘ä»£ç†é…ç½®æˆåŠŸæ¶ˆæ¯"""
    ipv4 = subprocess.run(['curl', '-s', 'ipv4.ip.sb'], capture_output=True, text=True).stdout.strip()
    ipv6 = subprocess.run(['curl', '-s', '--max-time', '1', 'ipv6.ip.sb'], capture_output=True, text=True).stdout.strip()
    
    success_msg = 'âœ… åå‘ä»£ç†é…ç½®å®Œæˆ!\n\nè®¿é—®åœ°å€:\n'
    if ipv4:
        success_msg += f'http://{ipv4}:{proxy_data["target_port"]}\n'
    if ipv6:
        success_msg += f'http://[{ipv6}]:{proxy_data["target_port"]}\n'
    success_msg += f'https://{proxy_data["domain"]}'
    
    await event.respond(success_msg)

# å¤„ç†æ–‡ä»¶å¤¹åˆ›å»ºçš„æ¶ˆæ¯
async def handle_mkdir_message(event, user_state):
    """å¤„ç†åˆ›å»ºæ–‡ä»¶å¤¹çš„æ¶ˆæ¯"""
    new_folder_name = event.text.strip()
    new_folder_path = pathlib.Path(user_state.current_path) / new_folder_name
    new_folder_path.mkdir(exist_ok=True)
    
    buttons = await refresh_directory_view(event, user_state.current_path)
    await event.respond(
        f'âœ… æ–‡ä»¶å¤¹ "{new_folder_name}" åˆ›å»ºæˆåŠŸ!\n'
        f'ğŸ“‚ å½“å‰ç›®å½•: {user_state.current_path}',
        buttons=buttons
    )

# å¤„ç†æ–‡ä»¶åˆ›å»ºçš„æ¶ˆæ¯
async def handle_mkfile_message(event, user_state):
    """å¤„ç†åˆ›å»ºæ–‡ä»¶çš„æ¶ˆæ¯"""
    new_file_name = event.text.strip()
    new_file_path = pathlib.Path(user_state.current_path) / new_file_name
    new_file_path.touch()
    
    buttons = await refresh_directory_view(event, user_state.current_path)
    await event.respond(
        f'âœ… æ–‡ä»¶ "{new_file_name}" åˆ›å»ºæˆåŠŸ!\n'
        f'ğŸ“‚ å½“å‰ç›®å½•: {user_state.current_path}',
        buttons=buttons
    )

# å¤„ç†æ–‡ä»¶ç¼–è¾‘çš„æ¶ˆæ¯
async def handle_edit_message(event, user_state):
    """å¤„ç†ç¼–è¾‘æ–‡ä»¶çš„æ¶ˆæ¯"""
    new_content = event.text
    path = pathlib.Path(user_state.edit_file_path)
    path.write_text(new_content, encoding='utf-8')
    
    # è·å–æ–‡ä»¶æ‰€åœ¨ç›®å½•
    current_path = str(path.parent)
    buttons = await refresh_directory_view(event, current_path)
    await event.respond(
        f'âœ… æ–‡ä»¶ "{path.name}" å·²æ›´æ–°!\n'
        f'ğŸ“‚ å½“å‰ç›®å½•: {current_path}',
        buttons=buttons
    )

# ä¸»æ¶ˆæ¯å¤„ç†å‡½æ•°
@bot.on(events.NewMessage())
async def handle_new_message(event):
    """å¤„ç†æ–°æ¶ˆæ¯"""
    if event.sender_id not in ALLOWED_USERS:
        return
        
    user_state = user_states.get(event.sender_id)
    if not user_state:
        return
        
    try:
        if user_state.waiting_proxy:
            await handle_proxy_message(event, user_state)
        elif user_state.waiting_mkdir:
            await handle_mkdir_message(event, user_state)
        elif user_state.waiting_mkfile:
            await handle_mkfile_message(event, user_state)
        elif user_state.waiting_edit:
            await handle_edit_message(event, user_state)
            
    except Exception as e:
        await event.respond(f'âŒ æ“ä½œå¤±è´¥: {str(e)}')
    finally:
        if not user_state.waiting_proxy:  # åªåœ¨éåä»£çŠ¶æ€æ—¶é‡ç½®å…¶ä»–çŠ¶æ€
            user_state.waiting_mkdir = False
            user_state.waiting_mkfile = False 
            user_state.waiting_edit = False
            user_state.current_path = None
            user_state.edit_file_path = None

# æ·»åŠ åˆ é™¤æ–‡ä»¶å¤¹çš„å¤„ç†å‡½æ•°
@bot.on(events.CallbackQuery(pattern=r'rmdir:(.+)'))
async def rmdir_confirm(event):
    """ç¡®è®¤åˆ é™¤æ–‡ä»¶å¤¹"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    path = event.pattern_match.group(1).decode()
    path_obj = pathlib.Path(path)
    
    try:
        buttons = [
            [
                Button.inline('âœ… ç¡®è®¤åˆ é™¤', f'rmdir_do:{path}'),
                Button.inline('âŒ å–æ¶ˆ', 'cancel')
            ]
        ]
        
        await event.respond(
            f'âš ï¸ ç¡®è®¤è¦åˆ é™¤æ–‡ä»¶å¤¹å—ï¼Ÿ\n'
            f'ğŸ“‚ è·¯å¾„: {path}',
            buttons=buttons
        )
        await event.answer()
    except Exception as e:
        print(f"ç¡®è®¤åˆ é™¤æ–‡ä»¶å¤¹æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")
        await event.answer(f'âŒ é”™è¯¯: {str(e)}', alert=True)

@bot.on(events.CallbackQuery(pattern=r'rmdir_do:(.+)'))
async def rmdir_execute(event):
    """æ‰§è¡Œåˆ é™¤æ–‡ä»¶å¤¹æ“ä½œ"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    path = event.pattern_match.group(1).decode()
    path_obj = pathlib.Path(path)
    
    try:
        # æ£€æŸ¥æ˜¯å¦ä¸ºç›®å½•
        if not path_obj.is_dir():
            await event.answer('âŒ è¿™ä¸æ˜¯ä¸€ä¸ªæ–‡ä»¶å¤¹', alert=True)
            return
            
        # å°è¯•åˆ é™¤ç›®å½•
        import shutil
        shutil.rmtree(path_obj)
        
        # è·å–çˆ¶ç›®å½•è·¯å¾„ç”¨äºåˆ·æ–°æ˜¾ç¤º
        parent_path = str(path_obj.parent)
        
        # åˆ é™¤ç¡®è®¤æ¶ˆæ¯
        try:
            await event.delete()
        except:
            pass  # å¿½ç•¥åˆ é™¤æ¶ˆæ¯å¯èƒ½å‡ºç°çš„é”™è¯¯
        
        # å‘é€æ–°æ¶ˆæ¯è€Œä¸æ˜¯ç¼–è¾‘
        buttons = []
        path_obj = pathlib.Path(parent_path)
        
        try:
            items = list(path_obj.iterdir())
            directories = [item for item in items if item.is_dir()]
            files = [item for item in items if item.is_file()]
            
            # æ·»åŠ ç›®å½•æŒ‰é’®
            dir_buttons = []
            for directory in directories:
                dir_buttons.append(Button.inline(f'ğŸ“ {directory.name}', f'cd:{directory}'))
                if len(dir_buttons) == 3:
                    buttons.append(dir_buttons)
                    dir_buttons = []
            if dir_buttons:
                buttons.append(dir_buttons)
            
            # æ·»åŠ æ–‡ä»¶æŒ‰é’®
            file_buttons = []
            for file in files:
                file_buttons.append(Button.inline(f'ğŸ“„ {file.name}', f'file:{file}'))
                if len(file_buttons) == 3:
                    buttons.append(file_buttons)
                    file_buttons = []
            if file_buttons:
                buttons.append(file_buttons)
            
            # æ·»åŠ åº•éƒ¨æ“ä½œæŒ‰é’®
            bottom_buttons = []
            bottom_buttons.append(Button.inline('ğŸ—‘ åˆ é™¤æ–‡ä»¶å¤¹', f'rmdir:{parent_path}'))
            bottom_buttons.append(Button.inline('â• åˆ›å»ºæ–‡ä»¶å¤¹', f'mkdir:{parent_path}'))
            buttons.append(bottom_buttons)
            
            # æ·»åŠ è¿”å›ä¸Šçº§ç›®å½•æŒ‰é’®åˆ°åº•éƒ¨
            if str(path_obj) != '/':
                buttons.append([Button.inline('ğŸ“‚ ..', f'cd:{path_obj.parent}')])
            
            await event.respond(
                f'âœ… æ–‡ä»¶å¤¹å·²åˆ é™¤\n\n'
                f'ğŸ“‚ å½“å‰ç›®å½•: {parent_path}',
                buttons=buttons
            )
        except Exception as e:
            print(f"åˆ·æ–°ç›®å½•æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")
            await event.respond(f'âŒ é”™è¯¯: {str(e)}')
            
    except Exception as e:
        print(f"åˆ é™¤æ–‡ä»¶å¤¹æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")
        await event.answer(f'âŒ åˆ é™¤å¤±è´¥: {str(e)}', alert=True)

# æ·»åŠ ç¼–è¾‘æ–‡ä»¶çš„å¤„ç†å‡½æ•°
@bot.on(events.CallbackQuery(pattern=r'edit:(.+)'))
async def edit_file_start(event):
    """å¼€å§‹ç¼–è¾‘æ–‡ä»¶æµç¨‹"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    file_path = event.pattern_match.group(1).decode()
    path = pathlib.Path(file_path)
    
    try:
        # æ£€æŸ¥æ–‡ä»¶å¤§å°
        if path.stat().st_size > 1024 * 1024:  # å¤§äº1MB
            await event.answer('âŒ æ–‡ä»¶å¤ªå¤§ï¼Œæ— æ³•ç¼–è¾‘', alert=True)
            return
            
        # å°è¯•è¯»å–å½“å‰å†…å®¹
        try:
            content = path.read_text(encoding='utf-8')
            # å¦‚æœå†…å®¹å¤ªé•¿ï¼Œåªæ˜¾ç¤ºå‰2000ä¸ªå­—ç¬¦
            if len(content) > 2000:
                content = content[:2000] + '\n... (å†…å®¹å·²æˆªæ–­ï¼Œä½†ç¼–è¾‘æ—¶å°†ä¿®æ”¹å®Œæ•´æ–‡ä»¶)'
        except UnicodeDecodeError:
            await event.answer('âŒ æ— æ³•ç¼–è¾‘äºŒè¿›åˆ¶æ–‡ä»¶', alert=True)
            return
        
        # ä¿å­˜ç”¨æˆ·çŠ¶æ€
        if event.sender_id not in user_states:
            user_states[event.sender_id] = UserState()
        user_states[event.sender_id].waiting_edit = True
        user_states[event.sender_id].edit_file_path = file_path
        
        buttons = [[Button.inline('ğŸš« å–æ¶ˆ', 'cancel')]]
        await event.respond(
            f'âœï¸ æ­£åœ¨ç¼–è¾‘: {path.name}\n'
            f'å½“å‰å†…å®¹:\n'
            f'```\n{content}\n```\n'
            f'è¯·å‘é€æ–°çš„æ–‡ä»¶å†…å®¹:',
            buttons=buttons
        )
        await event.answer()
        
    except Exception as e:
        print(f"å¼€å§‹ç¼–è¾‘æ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")
        await event.answer(f'âŒ é”™è¯¯: {str(e)}', alert=True)

# æ·»åŠ è¿è¡Œ Python æ–‡ä»¶çš„å¤„ç†å‡½æ•°
@bot.on(events.CallbackQuery(pattern=r'run:(.+)'))
async def run_python_file(event):
    """åœ¨åå°è¿è¡Œ Python æ–‡ä»¶"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    file_path = event.pattern_match.group(1).decode()
    path = pathlib.Path(file_path)
    
    try:
        # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨ä¸”æ˜¯ Python æ–‡ä»¶
        if not path.exists() or path.suffix != '.py':
            await event.answer('âŒ æ— æ•ˆçš„ Python æ–‡ä»¶', alert=True)
            return
        
        # ä½¿ç”¨ nohup åœ¨åå°è¿è¡Œ Python æ–‡ä»¶
        cmd = f'nohup python3 {path} > {path}.log 2>&1 &'
        os.system(cmd)
        
        # è·å–è¿›ç¨‹ ID
        result = subprocess.run(['pgrep', '-f', f'python3 {path}'], capture_output=True, text=True)
        pid = result.stdout.strip()
        
        await event.respond(
            f'âœ… æ–‡ä»¶å·²åœ¨åå°å¯åŠ¨\n'
            f'ğŸ“„ æ–‡ä»¶: {path.name}\n'
            f'ğŸ“ æ—¥å¿—: {path}.log\n'
            f'ğŸ”„ PID: {pid}'
        )
        await event.answer()
        
    except Exception as e:
        print(f"è¿è¡Œ Python æ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")
        await event.answer(f'âŒ è¿è¡Œå¤±è´¥: {str(e)}', alert=True)

# æ·»åŠ æŸ¥çœ‹è¿è¡Œä¸­çš„ Python ç¨‹åºçš„å¤„ç†å‡½æ•°
@bot.on(events.CallbackQuery(pattern='running_py'))
async def list_running_python(event):
    """åˆ—å‡ºæ‰€æœ‰è¿è¡Œä¸­çš„ Python ç¨‹åº"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    try:
        # ä½¿ç”¨ä¸¤ä¸ªå‘½ä»¤æ¥è·å–è¿›ç¨‹ä¿¡æ¯
        ps_cmd = ['ps', '-ef']
        ps_result = subprocess.run(ps_cmd, capture_output=True, text=True)
        
        # è¿‡æ»¤å¹¶æ ¼å¼åŒ–è¿›ç¨‹ä¿¡æ¯
        running_programs = []
        for line in ps_result.stdout.strip().split('\n'):
            if 'python3' in line and 'bot_session' not in line:  # æ’é™¤æœºå™¨äººè¿›ç¨‹
                parts = line.split()
                if len(parts) >= 8:
                    pid = parts[1]
                    cmd = ' '.join(parts[7:])
                    if '.py' in cmd:  # åªæ˜¾ç¤ºè¿è¡Œ Python æ–‡ä»¶çš„è¿›ç¨‹
                        running_programs.append((pid, cmd))
        
        if running_programs:
            # ä¸ºæ¯ä¸ªè¿›ç¨‹åˆ›å»ºåœæ­¢æŒ‰é’®
            buttons = []
            message = 'ğŸ”„ è¿è¡Œä¸­çš„ Python ç¨‹åº:\n\n'
            for pid, cmd in running_programs:
                message += f'ğŸ”¹ PID: {pid}\nğŸ“„ å‘½ä»¤: {cmd}\n\n'
                buttons.append([Button.inline(f'â¹ï¸ åœæ­¢ PID: {pid}', f'kill:{pid}')])
            
            buttons.append([Button.inline('ğŸ“‚ è¿”å›æ–‡ä»¶æµè§ˆå™¨', 'ls')])
            await event.edit(message, buttons=buttons)
        else:
            buttons = [[Button.inline('ğŸ“‚ è¿”å›æ–‡ä»¶æµè§ˆå™¨', 'ls')]]
            await event.edit('ğŸ“ å½“å‰æ²¡æœ‰è¿è¡Œä¸­çš„ Python ç¨‹åº', buttons=buttons)
            
    except Exception as e:
        print(f"è·å–è¿è¡Œä¸­çš„ Python ç¨‹åºæ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")
        await event.answer(f'âŒ é”™è¯¯: {str(e)}', alert=True)

# æ·»åŠ åœæ­¢è¿›ç¨‹çš„å¤„ç†å‡½æ•°
@bot.on(events.CallbackQuery(pattern=r'kill:(\d+)'))
async def kill_process(event):
    """åœæ­¢æŒ‡å®šçš„è¿›ç¨‹"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    pid = event.pattern_match.group(1)
    try:
        import signal
        os.kill(int(pid), signal.SIGTERM)
        await event.answer(f'âœ… è¿›ç¨‹ {pid} å·²åœæ­¢')
        # åˆ·æ–°è¿›ç¨‹åˆ—è¡¨
        await list_running_python(event)
    except ProcessLookupError:
        await event.answer(f'âŒ è¿›ç¨‹ {pid} ä¸å­˜åœ¨', alert=True)
    except Exception as e:
        print(f"åœæ­¢è¿›ç¨‹æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")
        await event.answer(f'âŒ é”™è¯¯: {str(e)}', alert=True)

# æ·»åŠ åˆ é™¤æ–‡ä»¶çš„å¤„ç†å‡½æ•°
@bot.on(events.CallbackQuery(pattern=r'rmfile:(.+)'))
async def rmfile_confirm(event):
    """ç¡®è®¤åˆ é™¤æ–‡ä»¶"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    file_path = event.pattern_match.group(1).decode()
    path = pathlib.Path(file_path)
    
    try:
        buttons = [
            [
                Button.inline('âœ… ç¡®è®¤åˆ é™¤', f'rmfile_do:{file_path}'),
                Button.inline('âŒ å–æ¶ˆ', 'cancel')
            ]
        ]
        
        await event.respond(
            f'âš ï¸ ç¡®è®¤è¦åˆ é™¤æ–‡ä»¶å—ï¼Ÿ\n'
            f'ğŸ“„ æ–‡ä»¶: {path.name}',
            buttons=buttons
        )
        await event.answer()
    except Exception as e:
        print(f"ç¡®è®¤åˆ é™¤æ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")
        await event.answer(f'âŒ é”™è¯¯: {str(e)}', alert=True)

@bot.on(events.CallbackQuery(pattern=r'rmfile_do:(.+)'))
async def rmfile_execute(event):
    """æ‰§è¡Œåˆ é™¤æ–‡ä»¶æ“ä½œ"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    file_path = event.pattern_match.group(1).decode()
    path = pathlib.Path(file_path)
    
    try:
        # æ£€æŸ¥æ˜¯å¦ä¸ºæ–‡ä»¶
        if not path.is_file():
            await event.answer('âŒ è¿™ä¸æ˜¯ä¸€ä¸ªæ–‡ä»¶', alert=True)
            return
            
        # åˆ é™¤æ–‡ä»¶
        path.unlink()
        
        # è·å–çˆ¶ç›®å½•è·¯å¾„ç”¨äºåˆ·æ–°æ˜¾ç¤º
        parent_path = str(path.parent)
        
        # åˆ é™¤ç¡®è®¤æ¶ˆæ¯
        try:
            await event.delete()
        except:
            pass  # å¿½ç•¥åˆ é™¤æ¶ˆæ¯å¯èƒ½å‡ºç°çš„  è¯¯
        
        # åˆ·æ–°ç›®å½•æ˜¾ç¤º
        await list_directory(event, path=parent_path)
        await event.answer('âœ… æ–‡ä»¶å·²åˆ é™¤')
        
    except Exception as e:
        print(f"åˆ é™¤æ–‡ä»¶æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")
        await event.answer(f'âŒ åˆ é™¤å¤±è´¥: {str(e)}', alert=True)

# æ·»åŠ åˆ›å»ºæ–‡ä»¶çš„å¤„ç†å‡½æ•°
@bot.on(events.CallbackQuery(pattern=r'mkfile:(.+)'))
async def mkfile_start(event):
    """å¼€å§‹åˆ›å»ºæ–‡ä»¶æµç¨‹"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    path = event.pattern_match.group(1).decode()
    
    # ä¿å­˜ç”¨æˆ·çŠ¶æ€
    if event.sender_id not in user_states:
        user_states[event.sender_id] = UserState()
    user_states[event.sender_id].waiting_mkfile = True
    user_states[event.sender_id].current_path = path
    
    buttons = [[Button.inline('ğŸš« å–æ¶ˆ', 'cancel')]]
    await event.respond('è¯·è¾“å…¥æ–°æ–‡ä»¶çš„åç§°:', buttons=buttons)
    await event.answer()

# æ·»åŠ ç©ºæ“ä½œçš„å¤„ç†å‡½æ•°
@bot.on(events.CallbackQuery(pattern='noop'))
async def handle_noop(event):
    """å¤„ç†ç©ºæ“ä½œæŒ‰é’®"""
    await event.answer('æ­¤ç›®å½•å†…å®¹è¿‡å¤šï¼Œä»…æ˜¾ç¤ºéƒ¨åˆ†å†…å®¹')

# æ·»åŠ åä»£å¤„ç†å‡½æ•°
@bot.on(events.CallbackQuery(pattern='proxy'))
async def proxy_start(event):
    """å¼€å§‹åå‘ä»£ç†é…ç½®"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    # ä¿å­˜ç”¨æˆ·çŠ¶æ€
    if event.sender_id not in user_states:
        user_states[event.sender_id] = UserState()
    user_state = user_states[event.sender_id]
    user_state.waiting_proxy = True
    user_state.proxy_step = 'domain'  # ç­‰å¾…è¾“å…¥åŸŸå
    
    buttons = [[Button.inline('ğŸš« å–æ¶ˆ', 'cancel')]]
    await event.respond('ğŸŒ åå‘ä»£ç†é…ç½®å‘å¯¼\n\nè¯·è¾“å…¥åŸŸå:', buttons=buttons)

# æ·»åŠ å¿«é€Ÿæµ‹è¯•å¤„ç†å‡½æ•°
@bot.on(events.CallbackQuery(pattern='quick_test'))
async def quick_test(event):
    """å¿«é€Ÿå¯åŠ¨æµ‹è¯•æœåŠ¡å™¨"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    try:
        # æ£€æŸ¥å¹¶å®‰è£… Flask
        try:
            import flask
        except ImportError:
            await event.edit('æ­£åœ¨å®‰è£…å¿…è¦çš„ä¾èµ–...')
            subprocess.run(['pip', 'install', 'flask'], check=True)
        
        # æ£€æŸ¥æµ‹è¯•æœåŠ¡å™¨æ˜¯å¦å·²è¿è¡Œ
        result = subprocess.run(['pgrep', '-f', 'test_server.py'], capture_output=True, text=True)
        if result.stdout.strip():
            await event.answer('âŒ æµ‹è¯•æœåŠ¡å™¨å·²åœ¨è¿è¡Œä¸­', alert=True)
            return
        
        # å¯åŠ¨æµ‹è¯•æœåŠ¡å™¨
        subprocess.Popen(['python3', 'test_server.py'])
        
        # è·å–IPåœ°å€
        ipv4 = subprocess.run(['curl', '-s', 'ipv4.ip.sb'], capture_output=True, text=True).stdout.strip()
        ipv6 = subprocess.run(['curl', '-s', '--max-time', '1', 'ipv6.ip.sb'], capture_output=True, text=True).stdout.strip()
        
        # å‘é€æç¤ºæ¶ˆæ¯
        msg = 'âœ… æµ‹è¯•æœåŠ¡å™¨å·²å¯åŠ¨!\n\n'
        msg += 'è®¿é—®åœ°å€:\n'
        if ipv4:
            msg += f'http://{ipv4}:5000\n'
        if ipv6:
            msg += f'http://[{ipv6}]:5000\n'
        msg += '\nå¯ä»¥é€šè¿‡ä»¥ä¸Šåœ°å€æµ‹è¯•åŸŸåè§£æã€‚\n'
        msg += 'æµ‹è¯•å®Œæˆåï¼Œè¯·åœ¨è¿è¡Œä¸­çš„ç¨‹åºä¸­åœæ­¢ test_server.py'
        
        buttons = [[Button.inline('ğŸ“‚ è¿”å›æ–‡ä»¶æµè§ˆå™¨', 'ls')]]
        await event.edit(msg, buttons=buttons)
        
    except Exception as e:
        print(f"å¯åŠ¨æµ‹è¯•æœåŠ¡å™¨æ—¶å‘ç”Ÿé”™è¯¯: {str(e)}")
        await event.answer(f'âŒ é”™è¯¯: {str(e)}', alert=True)

# æ·»åŠ  Docker ç®¡ç†åŠŸèƒ½
@bot.on(events.CallbackQuery(pattern='docker'))
async def docker_menu(event):
    """æ˜¾ç¤º Docker ç®¡ç†èœå•"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    try:
        # è·å–å®¹å™¨åˆ—è¡¨
        containers = subprocess.run(['docker', 'ps', '-a', '--format', '{{.Names}}\t{{.Status}}'], 
                                 capture_output=True, text=True).stdout.strip()
        
        msg = 'ğŸ³ Docker å®¹å™¨ç®¡ç†\n\n'
        buttons = []
        
        if containers:
            for container in containers.split('\n'):
                if container:
                    name, status = container.split('\t')
                    status_icon = 'ğŸŸ¢' if 'Up' in status else 'ğŸ”´'
                    buttons.append([Button.inline(f'{status_icon} {name}', f'docker_container:{name}')])
        else:
            msg += 'æ²¡æœ‰å‘ç°å®¹å™¨'
            
        # æ·»åŠ åº•éƒ¨æŒ‰é’®
        buttons.extend([
            [Button.inline('ğŸ”„ åˆ·æ–°åˆ—è¡¨', 'docker')],
            [Button.inline('ğŸ“‚ è¿”å›', 'ls')]
        ])
        
        await event.edit(msg, buttons=buttons)
    except Exception as e:
        await event.answer(f'âŒ é”™è¯¯: {str(e)}', alert=True)

@bot.on(events.CallbackQuery(pattern=r'docker_container:(.+)'))
async def docker_container_menu(event):
    """æ˜¾ç¤ºå®¹å™¨æ“ä½œèœå•"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    container = event.pattern_match.group(1).decode()
    
    try:
        # è·å–å®¹å™¨çŠ¶æ€
        status = subprocess.run(['docker', 'ps', '-a', '--filter', f'name={container}', '--format', '{{.Status}}'],
                              capture_output=True, text=True).stdout.strip()
        
        msg = f'ğŸ³ å®¹å™¨: {container}\nçŠ¶æ€: {status}\n\né€‰æ‹©æ“ä½œ:'
        buttons = []
        
        # æ ¹æ®å®¹å™¨çŠ¶æ€æ˜¾ç¤ºä¸åŒçš„æŒ‰é’®
        if 'Up' in status:
            buttons.extend([
                [Button.inline('â¹ï¸ åœæ­¢', f'docker_stop:{container}'),
                 Button.inline('ğŸ”„ é‡å¯', f'docker_restart:{container}')],
                [Button.inline('ğŸ“‹ æŸ¥çœ‹æ—¥å¿—', f'docker_logs:{container}')]
            ])
        else:
            buttons.append([Button.inline('â–¶ï¸ å¯åŠ¨', f'docker_start:{container}')])
            
        buttons.extend([
            [Button.inline('ğŸ—‘ï¸ åˆ é™¤', f'docker_rm:{container}')],
            [Button.inline('â—€ï¸ è¿”å›', 'docker')]
        ])
        
        await event.edit(msg, buttons=buttons)
    except Exception as e:
        await event.answer(f'âŒ é”™è¯¯: {str(e)}', alert=True)

# å¤„ç†å®¹å™¨æ“ä½œ
@bot.on(events.CallbackQuery(pattern=r'docker_(start|stop|restart|rm):(.+)'))
async def docker_operation(event):
    """æ‰§è¡Œå®¹å™¨æ“ä½œ"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    operation = event.pattern_match.group(1)
    container = event.pattern_match.group(2).decode()
    
    operations = {
        'start': ('å¯åŠ¨', ['docker', 'start']),
        'stop': ('åœæ­¢', ['docker', 'stop']),
        'restart': ('é‡å¯', ['docker', 'restart']),
        'rm': ('åˆ é™¤', ['docker', 'rm', '-f'])
    }
    
    try:
        op_name, cmd = operations[operation]
        cmd.append(container)
        
        # æ‰§è¡Œæ“ä½œ
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode == 0:
            await event.answer(f'âœ… {op_name}æˆåŠŸ')
        else:
            await event.answer(f'âŒ {op_name}å¤±è´¥: {result.stderr}', alert=True)
            
        # è¿”å›å®¹å™¨åˆ—è¡¨
        await docker_menu(event)
    except Exception as e:
        await event.answer(f'âŒ æ“ä½œå¤±è´¥: {str(e)}', alert=True)

@bot.on(events.CallbackQuery(pattern=r'docker_logs:(.+)'))
async def docker_logs(event):
    """æŸ¥çœ‹å®¹å™¨æ—¥å¿—"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    container = event.pattern_match.group(1).decode()
    
    try:
        # è·å–æœ€å100è¡Œæ—¥å¿—
        logs = subprocess.run(['docker', 'logs', '--tail', '100', container], 
                            capture_output=True, text=True).stdout.strip()
        
        msg = f'ğŸ“‹ {container} çš„æœ€æ–°æ—¥å¿—:\n\n```\n{logs[:4000]}\n```'  # é™åˆ¶é•¿åº¦
        if len(logs) > 4000:
            msg += '\n... (æ—¥å¿—å·²æˆªæ–­)'
            
        buttons = [[Button.inline('â—€ï¸ è¿”å›', f'docker_container:{container}')]]
        await event.edit(msg, buttons=buttons)
    except Exception as e:
        await event.answer(f'âŒ è·å–æ—¥å¿—å¤±è´¥: {str(e)}', alert=True)

# æ·»åŠ æµ‹é€Ÿç›¸å…³çš„å¤„ç†å‡½æ•°
@bot.on(events.CallbackQuery(pattern='speed_test'))
async def speed_test_menu(event):
    """æ˜¾ç¤ºæµ‹é€Ÿèœå•"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    buttons = [
        [Button.inline('â–¶ï¸ å¼€å§‹æµ‹é€Ÿ', 'start_speed_test')],
        [Button.inline('ğŸ“‚ è¿”å›', 'ls')]
    ]
    
    await event.edit('âš¡ï¸ æœåŠ¡å™¨æµ‹é€Ÿ\n\né€‰æ‹©æ“ä½œ:', buttons=buttons)

@bot.on(events.CallbackQuery(pattern='start_speed_test'))
async def start_speed_test(event):
    """å¼€å§‹æµ‹é€Ÿ"""
    if event.sender_id not in ALLOWED_USERS:
        return
    
    try:
        msg = await event.edit('â³ æ­£åœ¨è¿›è¡Œæµ‹é€Ÿ...\nè¿™å¯èƒ½éœ€è¦å‡ åˆ†é’Ÿæ—¶é—´')
        
        # åœ¨åå°è¿è¡Œæµ‹é€Ÿè„šæœ¬
        process = await asyncio.create_subprocess_exec(
            'python3', 'local_speed_test.py',
            stdout=asyncio.subprocess.PIPE,
            stderr=asyncio.subprocess.PIPE
        )
        
        stdout, stderr = await process.communicate()
        
        if process.returncode == 0:
            # ä»è¾“å‡ºä¸­æå–ç»“æœ
            output = stdout.decode()
            msg_text = 'ğŸ“Š æµ‹é€Ÿç»“æœ:\n\n'
            
            if 'æµ‹é€Ÿå¤±è´¥' in output:
                msg_text += f'âŒ {output}'
            else:
                for line in output.split('\n'):
                    if any(x in line.lower() for x in ['å»¶è¿Ÿ', 'ä¸‹è½½é€Ÿåº¦', 'ä¸Šä¼ é€Ÿåº¦']):
                        msg_text += f'{line}\n'
        else:
            msg_text = f'âŒ æµ‹é€Ÿå¤±è´¥:\n{stderr.decode()}'
        
        buttons = [[Button.inline('ğŸ”„ é‡æ–°æµ‹é€Ÿ', 'start_speed_test')],
                  [Button.inline('ğŸ“‚ è¿”å›', 'ls')]]
        await event.edit(msg_text, buttons=buttons)
        
    except Exception as e:
        await event.edit(f'âŒ é”™è¯¯: {str(e)}')

def main():
    """å¯åŠ¨æœºå™¨äºº"""
    print('æœºå™¨äººå·²å¯åŠ¨...')
    bot.run_until_disconnected()

if __name__ == '__main__':
    main()
