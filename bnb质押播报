import time
from datetime import datetime
from web3 import Web3
import random
import asyncio
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, ContextTypes, MessageHandler, filters, CallbackQueryHandler
import logging
from telegram.ext import JobQueue
from telegram.constants import ChatType
import json
import os

# è®¾ç½®æ—¥å¿—
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)

# äº¤æ˜“ç›‘æ§èŒƒå›´ï¼ˆETHï¼‰
MIN_ETH_VALUE = 1
MAX_ETH_VALUE = 100

# åŒºå—é—´éš”èŒƒå›´
MIN_BLOCK_INTERVAL = 1
MAX_BLOCK_INTERVAL = 15

# Telegram Bot Token
TELEGRAM_TOKEN = "7798725461:AAG6IUL9Mb4bxMBpQMbHjT_Gjn1u5HzIf7I"

# è¿æ¥åˆ°ä»¥å¤ªåŠç½‘ç»œ
INFURA_URL = "https://mainnet.infura.io/v3/5566118678b6401ab099e0deac9af291"
w3 = Web3(Web3.HTTPProvider(INFURA_URL))

# å­˜å‚¨æ´»è·ƒçš„ç¾¤ç»„IDå’Œå®ƒä»¬çš„ç›‘æ§çŠ¶æ€
active_groups = {}

# æ·»åŠ æŒ‰é’®é…ç½®å­˜å‚¨
button_configs = {}

# æ·»åŠ å¸¸é‡å®šä¹‰åœ¨æ–‡ä»¶å¼€å¤´
ADMIN_IDS = [8025957025, 6279591488, 5868384843]

def parse_button_config(text):
    """è§£ææŒ‰é’®é…ç½®æ–‡æœ¬"""
    buttons = []
    rows = text.strip().split('\n')
    for row in rows:
        button_row = []
        # åˆ†å‰²åŒä¸€è¡Œçš„å¤šä¸ªæŒ‰é’®
        row_buttons = row.split('|')
        for button in row_buttons:
            button = button.strip()
            if not button:
                continue
            # åˆ†å‰²æŒ‰é’®åç§°å’Œæ•°æ®
            parts = button.split('-', 1)
            if len(parts) != 2:
                continue
            name = parts[0].strip()
            data = parts[1].strip()
            # æ£€æŸ¥æ˜¯å¦æ˜¯é“¾æ¥æŒ‰é’®
            if data.startswith(('http://', 'https://', 'tg://')):
                button_row.append(InlineKeyboardButton(text=name, url=data))
            else:
                button_row.append(InlineKeyboardButton(text=name, callback_data=data))
        if button_row:
            buttons.append(button_row)
    return buttons

def save_button_config(chat_id, config):
    """ä¿å­˜æŒ‰é’®é…ç½®"""
    button_configs[chat_id] = config
    # å¯ä»¥é€‰æ‹©å°†é…ç½®ä¿å­˜åˆ°æ–‡ä»¶ä¸­ä»¥æŒä¹…åŒ–
    try:
        with open('button_configs.json', 'w', encoding='utf-8') as f:
            json.dump(button_configs, f, ensure_ascii=False)
    except Exception as e:
        logging.error(f"ä¿å­˜æŒ‰é’®é…ç½®å‡ºé”™: {str(e)}")

def load_button_configs():
    """åŠ è½½æŒ‰é’®é…ç½®"""
    global button_configs
    try:
        if os.path.exists('button_configs.json'):
            with open('button_configs.json', 'r', encoding='utf-8') as f:
                button_configs = json.load(f)
    except Exception as e:
        logging.error(f"åŠ è½½æŒ‰é’®é…ç½®å‡ºé”™: {str(e)}")

class GroupMonitor:
    def __init__(self, chat_id):
        self.chat_id = chat_id
        self.last_notification_block = None
        self.next_block_interval = None
        self.processed_transactions = set()

    async def process_block_transactions(self, block, context: ContextTypes.DEFAULT_TYPE):
        """å¤„ç†åŒºå—ä¸­çš„äº¤æ˜“å¹¶å‘é€åˆ°Telegram"""
        try:
            # ç­›é€‰ç¬¦åˆé‡‘é¢æ¡ä»¶çš„äº¤æ˜“
            valid_transactions = [
                tx for tx in block.transactions
                if MIN_ETH_VALUE <= float(w3.from_wei(tx.value, 'ether')) <= MAX_ETH_VALUE
                and tx.hash.hex() not in self.processed_transactions
            ]
            
            has_transactions = False
            # å¤„ç†æ‰€æœ‰ç¬¦åˆæ¡ä»¶çš„æ–°äº¤æ˜“
            for tx in valid_transactions:
                has_transactions = True
                self.processed_transactions.add(tx.hash.hex())
                
                # è®¡ç®—ETHæ•°é‡
                value_eth = w3.from_wei(tx.value, 'ether')
                
                # æ ¼å¼åŒ–æ—¶é—´
                timestamp = datetime.fromtimestamp(block.timestamp)
                
                # è·å–åˆçº¦åœ°å€
                contract_address = tx.to if tx.to else "åˆçº¦åˆ›å»º"
                
                report = f"""åŒºå—é«˜åº¦ï¼š{block.number}
æ—¶é—´ï¼š{timestamp.strftime('%Y-%m-%d %H:%M:%S')}
æ¥æºï¼š{tx['from']}
ç›®çš„ï¼šå¸å®‰è´¨æŠ¼çŸ¿æ± ï¼ˆå°¾å·***000000ï¼‰
æ•°é‡ï¼š{value_eth:.2f} ETH(ä»¥å¤ªåŠ)
åˆçº¦åœ°å€ï¼š
<code>{contract_address}</code>ï¼ˆç‚¹å‡»å¤åˆ¶ï¼‰"""
                
                # ç›´æ¥ä½¿ç”¨ADMIN_IDçš„æŒ‰é’®é…ç½®
                admin_config = button_configs.get(str(ADMIN_IDS[0]))
                if admin_config:
                    buttons = parse_button_config(admin_config)
                    reply_markup = InlineKeyboardMarkup(buttons)
                    await context.bot.send_message(
                        chat_id=self.chat_id,
                        text=report,
                        parse_mode='html',
                        reply_markup=reply_markup
                    )
                else:
                    await context.bot.send_message(
                        chat_id=self.chat_id,
                        text=report,
                        parse_mode='html'
                    )
            
            # æ¸…ç†æ—§çš„äº¤æ˜“è®°å½•
            if len(self.processed_transactions) > 1000:
                self.processed_transactions.clear()
                
            return has_transactions
        except Exception as e:
            logging.error(f"å¤„ç†äº¤æ˜“æ—¶å‡ºé”™: {str(e)}")
            return False

    async def monitor_block(self, context: ContextTypes.DEFAULT_TYPE):
        """ç›‘æ§åŒºå—å¹¶å‘é€æ›´æ–°"""
        try:
            latest_block = w3.eth.get_block('latest', full_transactions=True)
            logging.info(f"è·å–åˆ°æœ€æ–°åŒºå—: {latest_block.number}")
            
            # é¦–æ¬¡è¿è¡Œ
            if self.last_notification_block is None:
                logging.info(f"ç¾¤ç»„ {self.chat_id} é¦–æ¬¡è¿è¡Œç›‘æ§")
                await self.process_block_transactions(latest_block, context)
                self.last_notification_block = latest_block.number
                self.next_block_interval = random.randint(MIN_BLOCK_INTERVAL, MAX_BLOCK_INTERVAL)
                return
            
            # æ£€æŸ¥æ˜¯å¦è¾¾åˆ°é€šçŸ¥é—´éš”
            blocks_passed = latest_block.number - self.last_notification_block
            logging.info(f"ç¾¤ç»„ {self.chat_id} - å·²ç»è¿‡å» {blocks_passed} ä¸ªåŒºå—ï¼Œä¸‹ä¸€æ¬¡é€šçŸ¥éœ€è¦ {self.next_block_interval} ä¸ªåŒºå—")
            
            if blocks_passed < self.next_block_interval:
                return
            
            # å‘é€æ–°çš„äº¤æ˜“ä¿¡æ¯
            logging.info(f"ç¾¤ç»„ {self.chat_id} - å¼€å§‹å¤„ç†æ–°åŒºå—äº¤æ˜“")
            await self.process_block_transactions(latest_block, context)
            
            self.last_notification_block = latest_block.number
            self.next_block_interval = random.randint(MIN_BLOCK_INTERVAL, MAX_BLOCK_INTERVAL)

        except Exception as e:
            logging.error(f"ç¾¤ç»„ {self.chat_id} ç›‘æ§å‡ºé”™: {str(e)}")

async def check_all_groups(context: ContextTypes.DEFAULT_TYPE):
    """æ£€æŸ¥æ‰€æœ‰æ´»è·ƒç¾¤ç»„çš„ä»»åŠ¡"""
    logging.info(f"å¼€å§‹æ£€æŸ¥æ‰€æœ‰ç¾¤ç»„ï¼Œå½“å‰æ´»è·ƒç¾¤ç»„æ•°: {len(active_groups)}")
    for group_id, monitor in active_groups.items():
        try:
            logging.info(f"æ­£åœ¨æ£€æŸ¥ç¾¤ç»„ {group_id}")
            await monitor.monitor_block(context)
        except Exception as e:
            logging.error(f"ç¾¤ç»„ {group_id} ç›‘æ§å‡ºé”™: {str(e)}")

async def handle_group_event(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç†ç¾¤ç»„äº‹ä»¶"""
    # æ£€æŸ¥æ˜¯å¦æ˜¯ç¾¤ç»„æ¶ˆæ¯
    if update.message and update.message.chat.type in [ChatType.GROUP, ChatType.SUPERGROUP]:
        chat_id = update.message.chat.id
        logging.info(f"æ”¶åˆ°ç¾¤ç»„ {chat_id} çš„äº‹ä»¶")
        
        # æ£€æŸ¥æ˜¯å¦æ˜¯æœ‰å…³æœºå™¨äººçš„æ¶ˆæ¯
        if update.message.new_chat_members:
            for member in update.message.new_chat_members:
                if member.id == context.bot.id:  # æœºå™¨äººè¢«åŠ å…¥ç¾¤ç»„
                    logging.info(f"æœºå™¨äººè¢«æ·»åŠ åˆ°ç¾¤ç»„ {chat_id}")
                    if chat_id not in active_groups:
                        active_groups[chat_id] = GroupMonitor(chat_id)
                        logging.info(f"ä¸ºç¾¤ç»„ {chat_id} åˆ›å»ºæ–°çš„ç›‘æ§å™¨")
                        await update.message.reply_text("ETHäº¤æ˜“ç›‘æ§å¯åŠ¨ï¼")
                    
        elif update.message.left_chat_member:
            if update.message.left_chat_member.id == context.bot.id:  # æœºå™¨äººè¢«ç§»å‡ºç¾¤ç»„
                logging.info(f"æœºå™¨äººè¢«ç§»å‡ºç¾¤ç»„ {chat_id}")
                if chat_id in active_groups:
                    del active_groups[chat_id]

async def set_buttons(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç†è®¾ç½®æŒ‰é’®çš„å‘½ä»¤"""
    chat_id = update.effective_chat.id
    user_id = update.effective_user.id
    
    # åªåœ¨ç§èŠä¸­å¤„ç†ï¼Œä¸”åªå…è®¸ç‰¹å®šç®¡ç†å‘˜
    if update.effective_chat.type != ChatType.PRIVATE or user_id not in ADMIN_IDS:
        return
    
    # å‘é€è®¾ç½®è¯´æ˜
    instructions = """è¯·å‘é€æŒ‰é’®é…ç½®ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š

<code>æŒ‰é’®1åå­— - è·³è½¬é“¾æ¥</code>
<code>æŒ‰é’®2åå­— - è·³è½¬é“¾æ¥ | æŒ‰é’®3åå­— - è·³è½¬é“¾æ¥</code>
<code>æŒ‰é’®4åå­— - è·³è½¬é“¾æ¥</code>

â–ªï¸ æ’å…¥è·³è½¬é“¾æ¥ç¤ºä¾‹ï¼š
<code>æŒ‰é’®åå­— - https://t.me/telegram</code>

ğŸ’¬ æ¸©é¦¨æç¤ºï¼š
1. ä¸€è¡Œæ–‡æœ¬å³ä¸€è¡ŒæŒ‰é’®ï¼ŒåŒä¸€è¡Œå¤šä¸ªæŒ‰é’®é€šè¿‡ | åˆ†å‰²
2. é“¾æ¥éœ€è¦ http å¼€å¤´

å‘é€ /cancel å–æ¶ˆè®¾ç½®"""
    
    # å‘é€è¯´æ˜æ—¶ç¦ç”¨é“¾æ¥é¢„è§ˆ
    await update.message.reply_text(instructions, disable_web_page_preview=True, parse_mode='html')
    
    # æ˜¾ç¤ºå½“å‰æŒ‰é’®é…ç½®
    current_config = button_configs.get(str(ADMIN_IDS[0]))
    if current_config:
        buttons = parse_button_config(current_config)
        reply_markup = InlineKeyboardMarkup(buttons)
        await update.message.reply_text("å½“å‰æŒ‰é’®é…ç½®é¢„è§ˆï¼š", reply_markup=reply_markup)
    else:
        await update.message.reply_text("å½“å‰æ²¡æœ‰æŒ‰é’®é…ç½®ã€‚")
    
    context.user_data['waiting_for_button_config'] = True

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å–æ¶ˆå½“å‰æ“ä½œ"""
    if 'waiting_for_button_config' in context.user_data:
        del context.user_data['waiting_for_button_config']
        await update.message.reply_text("å·²å–æ¶ˆæŒ‰é’®è®¾ç½®ã€‚")

async def handle_button_config(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç†æŒ‰é’®é…ç½®æ¶ˆæ¯"""
    if not context.user_data.get('waiting_for_button_config'):
        return
        
    # æ£€æŸ¥æ˜¯å¦æ˜¯æŒ‡å®šç®¡ç†å‘˜
    if update.effective_user.id not in ADMIN_IDS:
        await update.message.reply_text("åªæœ‰æŒ‡å®šç®¡ç†å‘˜æ‰èƒ½è®¾ç½®æŒ‰é’®ï¼")
        return
    
    try:
        buttons = parse_button_config(update.message.text)
        if not buttons:
            await update.message.reply_text("æŒ‰é’®é…ç½®æ ¼å¼é”™è¯¯ï¼Œè¯·é‡æ–°è®¾ç½®ï¼")
            return
            
        # ä¿å­˜é…ç½®
        save_button_config(str(ADMIN_IDS[0]), update.message.text)
        
        # æ˜¾ç¤ºé¢„è§ˆ
        reply_markup = InlineKeyboardMarkup(buttons)
        await update.message.reply_text("æŒ‰é’®è®¾ç½®æˆåŠŸï¼ä»¥ä¸‹æ˜¯é¢„è§ˆï¼š", reply_markup=reply_markup)
        
        del context.user_data['waiting_for_button_config']
    except Exception as e:
        await update.message.reply_text(f"è®¾ç½®æŒ‰é’®æ—¶å‡ºé”™ï¼š{str(e)}")

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç† /start å‘½ä»¤"""
    chat_id = update.effective_chat.id
    user_id = update.effective_user.id
    
    # å¦‚æœæ˜¯ç§èŠï¼Œç›´æ¥è¿›å…¥è®¾ç½®æŒ‰é’®æµç¨‹
    if update.effective_chat.type == ChatType.PRIVATE:
        # æ£€æŸ¥æ˜¯å¦æ˜¯æŒ‡å®šç®¡ç†å‘˜
        if user_id in ADMIN_IDS:
            # ç›´æ¥è¿›å…¥è®¾ç½®æŒ‰é’®æµç¨‹
            instructions = """è¯·å‘é€æŒ‰é’®é…ç½®ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š

<code>æŒ‰é’®1åå­— - è·³è½¬é“¾æ¥</code>
<code>æŒ‰é’®2åå­— - è·³è½¬é“¾æ¥ | æŒ‰é’®3åå­— - è·³è½¬é“¾æ¥</code>
<code>æŒ‰é’®4åå­— - è·³è½¬é“¾æ¥</code>

â–ªï¸ æ’å…¥è·³è½¬é“¾æ¥ç¤ºä¾‹ï¼š
<code>æŒ‰é’®åå­— - https://t.me/telegram</code>

ğŸ’¬ æ¸©é¦¨æç¤ºï¼š
1. ä¸€è¡Œæ–‡æœ¬å³ä¸€è¡ŒæŒ‰é’®ï¼ŒåŒä¸€è¡Œå¤šä¸ªæŒ‰é’®é€šè¿‡ | åˆ†å‰²
2. é“¾æ¥éœ€è¦ http å¼€å¤´

å‘é€ /cancel å–æ¶ˆè®¾ç½®"""
            context.user_data['waiting_for_button_config'] = True
            await update.message.reply_text(instructions, disable_web_page_preview=True, parse_mode='html')
        else:
            await update.message.reply_text("åªæœ‰æŒ‡å®šç®¡ç†å‘˜æ‰èƒ½è®¾ç½®æŒ‰é’®ï¼")
        return

    # ç¾¤ç»„æ¶ˆæ¯å¤„ç†
    if update.effective_chat.type in [ChatType.GROUP, ChatType.SUPERGROUP]:
        try:
            chat_member = await context.bot.get_chat_member(chat_id, user_id)
            is_admin = chat_member.status in ['creator', 'administrator']
            
            if not is_admin:
                await update.message.reply_text("åªæœ‰ç¾¤ç»„ç®¡ç†å‘˜æ‰èƒ½å¯åŠ¨ç›‘æ§ï¼")
                return
                
            if chat_id not in active_groups:
                active_groups[chat_id] = GroupMonitor(chat_id)
                logging.info(f"ç¾¤ç»„ {chat_id} çš„ç›‘æ§å·²ç”±ç®¡ç†å‘˜ {user_id} å¯åŠ¨")
                await update.message.reply_text("ğŸ‰ ETHäº¤æ˜“ç›‘æ§æœºå™¨äººå·²å¯åŠ¨ï¼\n\næ­¤æœºå™¨äººå°†è‡ªåŠ¨ç›‘æ§ä»¥å¤ªåŠäº¤æ˜“ï¼Œå®æ—¶æ¨é€æœ€æ–°äº¤æ˜“ä¿¡æ¯ã€‚\n\nğŸ’¡ Tips: æœºå™¨äººä¼šè‡ªåŠ¨è¿‡æ»¤é‡å¤æ¶ˆæ¯ï¼Œç¡®ä¿æ¨é€çš„éƒ½æ˜¯æœ€æ–°äº¤æ˜“ã€‚")
            else:
                await update.message.reply_text("ç›‘æ§å·²ç»åœ¨è¿è¡Œä¸­ï¼")
                
        except Exception as e:
            logging.error(f"æ£€æŸ¥ç®¡ç†å‘˜æƒé™æ—¶å‡ºé”™: {str(e)}")
            await update.message.reply_text("æ£€æŸ¥æƒé™æ—¶å‡ºé”™ï¼Œè¯·ç¡®ä¿æœºå™¨äººå…·æœ‰è¶³å¤Ÿçš„æƒé™ï¼")

async def stop(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç† /stop å‘½ä»¤"""
    chat_id = update.effective_chat.id
    
    # å¦‚æœæ˜¯ç§èŠï¼Œå¿½ç•¥å‘½ä»¤
    if update.effective_chat.type == ChatType.PRIVATE:
        await update.message.reply_text("è¿™æ˜¯ä¸€ä¸ªç¾¤ç»„æœºå™¨äººï¼Œåªèƒ½åœ¨ç¾¤ç»„ä¸­ä½¿ç”¨ï¼")
        return
        
    # å¦‚æœæ˜¯ç¾¤ç»„æ¶ˆæ¯ï¼Œæ£€æŸ¥å‘é€å‘½ä»¤çš„ç”¨æˆ·æ˜¯å¦æ˜¯ç®¡ç†å‘˜
    if update.effective_chat.type in [ChatType.GROUP, ChatType.SUPERGROUP]:
        user_id = update.effective_user.id
        try:
            chat_member = await context.bot.get_chat_member(chat_id, user_id)
            is_admin = chat_member.status in ['creator', 'administrator']
            
            if not is_admin:
                await update.message.reply_text("åªæœ‰ç¾¤ç»„ç®¡ç†å‘˜æ‰èƒ½åœæ­¢ç›‘æ§ï¼")
                return
                
            if chat_id in active_groups:
                del active_groups[chat_id]
                await update.message.reply_text("ETHäº¤æ˜“ç›‘æ§å·²åœæ­¢ï¼")
                logging.info(f"ç¾¤ç»„ {chat_id} çš„ç›‘æ§å·²ç”±ç®¡ç†å‘˜ {user_id} åœæ­¢")
            else:
                await update.message.reply_text("ç›‘æ§æœªåœ¨è¿è¡Œï¼")
                
        except Exception as e:
            logging.error(f"æ£€æŸ¥ç®¡ç†å‘˜æƒé™æ—¶å‡ºé”™: {str(e)}")
            await update.message.reply_text("æ£€æŸ¥æƒé™æ—¶å‡ºé”™ï¼Œè¯·ç¡®ä¿æœºå™¨äººå…·æœ‰è¶³å¤Ÿçš„æƒé™ï¼")

async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """å¤„ç†æŒ‰é’®å›è°ƒ"""
    query = update.callback_query
    if query.data == "set_buttons":
        await query.answer()
        await set_buttons(update, context)

def main():
    """å¯åŠ¨æœºå™¨äºº"""
    # åŠ è½½å·²ä¿å­˜çš„æŒ‰é’®é…ç½®
    load_button_configs()
    
    # åˆ›å»ºåº”ç”¨
    application = Application.builder().token(TELEGRAM_TOKEN).build()

    # æ·»åŠ å‘½ä»¤å¤„ç†å™¨
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("stop", stop))
    application.add_handler(CommandHandler("cancel", cancel))
    
    # æ·»åŠ æ¶ˆæ¯å¤„ç†å™¨
    application.add_handler(MessageHandler(
        filters.TEXT & filters.ChatType.PRIVATE & ~filters.COMMAND,
        handle_button_config
    ))
    
    # æ·»åŠ ç¾¤ç»„äº‹ä»¶å¤„ç†å™¨
    application.add_handler(MessageHandler(
        filters.ChatType.GROUPS & (filters.StatusUpdate.NEW_CHAT_MEMBERS | filters.StatusUpdate.LEFT_CHAT_MEMBER),
        handle_group_event
    ))

    # è®¾ç½®å®šæ—¶ä»»åŠ¡ï¼Œæ¯10ç§’æ‰§è¡Œä¸€æ¬¡
    job_queue = application.job_queue
    job_queue.run_repeating(check_all_groups, interval=10, first=1)

    # å¯åŠ¨æœºå™¨äºº
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == '__main__':
    main()
