import logging
import json
import time
import requests
import asyncio
from datetime import datetime
from telethon import TelegramClient
from telethon.tl.custom import Button
from tronapi import Tron
from decimal import Decimal
from telethon import events

# é…ç½®æ—¥å¿—
logging.basicConfig(format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO)
logger = logging.getLogger(__name__)

class WalletMonitor:
    def __init__(self, api_id, api_hash, bot_token, tron_api_key, control_address, bot_username, customer_service_id, group_link):
        """åˆå§‹åŒ–é’±åŒ…ç›‘æ§å™¨"""
        self.client = TelegramClient('wallet_monitor_bot', api_id, api_hash)
        self.bot_token = bot_token
        self.tron = Tron()
        self.tron_api_key = tron_api_key
        self.control_address = control_address
        self.bot_username = bot_username
        self.customer_service_id = customer_service_id
        self.group_link = group_link
        
        # ä»æ–‡ä»¶åŠ è½½ç›‘å¬çš„åœ°å€
        self.monitored_addresses = self.load_monitored_addresses()
        
        # è®¾ç½® TRON API
        self.tron.private_key = None
        self.tron.default_address = None
        self.tron.tron.setDefaultBlock('latest')

    def load_monitored_addresses(self):
        """ä»æ–‡ä»¶åŠ è½½ç›‘å¬çš„åœ°å€"""
        addresses = {}
        try:
            with open('ç›‘å¬.txt', 'r', encoding='utf-8') as f:
                for line in f:
                    try:
                        timestamp, chat_id_str, address_str = line.strip().split(' - ')
                        chat_id = int(chat_id_str.split(': ')[1])
                        address = address_str.split(': ')[1]
                        if address not in addresses:
                            addresses[address] = []
                        addresses[address].append(chat_id)
                    except Exception as e:
                        logger.error(f"Error parsing line {line}: {e}")
        except FileNotFoundError:
            open('ç›‘å¬.txt', 'w', encoding='utf-8').close()
        return addresses

    async def get_account_info(self, address):
        """è·å–è´¦æˆ·ä¿¡æ¯"""
        url = f"https://apilist.tronscan.org/api/account?address={address}"
        try:
            async with self.client.session.get(url) as response:
                account_info = await response.json()
                
                balance = int(account_info["balance"]) / 1000000
                energy_used = account_info["bandwidth"]["energyUsed"]
                energy_limit = account_info["bandwidth"]["energyLimit"]
                energy_remaining = energy_limit - energy_used
                bandwidth_used = account_info["bandwidth"]["freeNetUsed"]
                bandwidth_limit = account_info["bandwidth"]["freeNetLimit"]
                bandwidth_remaining = bandwidth_limit - bandwidth_used

                usdt_balance = 0.0
                for token in account_info.get("trc20token_balances", []):
                    if token["tokenAbbr"] == "USDT":
                        usdt_balance = int(token["balance"]) / (10 ** int(token["tokenDecimal"]))
                        break

                return energy_remaining, bandwidth_remaining, balance, usdt_balance
        except Exception as e:
            logger.error(f"Error getting account info for {address}: {e}")
            return None, None, None, None

    async def get_account_info_with_retry(self, address, max_retries=3):
        """å¸¦é‡è¯•æœºåˆ¶çš„è´¦æˆ·ä¿¡æ¯è·å–"""
        for i in range(max_retries):
            try:
                result = await self.get_account_info(address)
                if result[0] is not None:
                    return result
            except Exception as e:
                logger.error(f"Attempt {i+1} failed: {e}")
                if i < max_retries - 1:
                    await asyncio.sleep(2 ** i)  # æŒ‡æ•°é€€é¿
        return None, None, None, None

    async def monitor_transaction(self, block):
        """ç›‘æ§äº¤æ˜“"""
        try:
            formatted_date_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            keyboard = [
                [
                    Button.url("è‡ªåŠ©æœåŠ¡", self.bot_username),
                    Button.url("è”ç³»å®¢æœ", self.customer_service_id)
                ]
            ]

            for transaction in block['transactions']:
                if transaction['ret'][0]['contractRet'] != 'SUCCESS':
                    continue

                contract = transaction['raw_data']['contract'][0]
                contract_type = contract['type']
                value = contract['parameter']['value']

                if contract_type == 'TriggerSmartContract' and value['contract_address'] == '41a614f803b6fd780986a42c78ec9c7f77e6ded13c':
                    # USDTäº¤æ˜“å¤„ç†
                    await self.handle_usdt_transaction(transaction, formatted_date_time, keyboard)
                elif contract_type == 'TransferContract':
                    # TRXäº¤æ˜“å¤„ç†
                    await self.handle_trx_transaction(transaction, formatted_date_time, keyboard)

        except Exception as e:
            logger.error(f"Error monitoring transaction: {e}")

    async def handle_usdt_transaction(self, transaction, formatted_date_time, keyboard):
        """å¤„ç†USDTäº¤æ˜“"""
        value = transaction['raw_data']['contract'][0]['parameter']['value']
        data = value['data']
        
        if data[:8] != 'a9059cbb':
            return

        to_address = self.tron.address.from_hex('41' + data[32:72]).decode()
        from_address = self.tron.address.from_hex(value['owner_address']).decode()
        amount = int(data[72:136], 16) / 1000000

        # æ”¶æ¬¾ç›‘å¬
        if to_address in self.monitored_addresses:
            energy_remaining, bandwidth_remaining, balance, usdt_balance = await self.get_account_info(to_address)
            for chat_id in self.monitored_addresses[to_address]:
                try:
                    message = (
                        f'âœ…*æ”¶å…¥åˆ°è´¦ +{amount}USDT*\n'
                        f'ä»˜æ¬¾åœ°å€ï¼š`{from_address}`\n'
                        f'æ”¶æ¬¾åœ°å€ï¼š`{to_address}`\n'
                        f'äº¤æ˜“æ—¶é—´ï¼š{formatted_date_time}\n'
                        f'äº¤æ˜“é‡‘é¢ï¼š{amount}USDT\n'
                        f'è´¦æˆ·ä½™é¢ï¼š{round(balance, 2)}TRXï¼Œ{round(usdt_balance, 2)}USDT'
                    )
                    await self.client.send_message(chat_id, message, buttons=keyboard, parse_mode='markdown')
                except Exception as e:
                    logger.error(f"Error sending USDT transaction message to {chat_id}: {e}")

        # æ”¯å‡ºç›‘å¬
        if from_address in self.monitored_addresses:
            energy_remaining, bandwidth_remaining, balance, usdt_balance = await self.get_account_info(from_address)
            for chat_id in self.monitored_addresses[from_address]:
                try:
                    message = (
                        f'â*æ”¯å‡ºæé†’ -{amount}USDT*\n'
                        f'ä»˜æ¬¾åœ°å€ï¼š`{from_address}`\n'
                        f'æ”¶æ¬¾åœ°å€ï¼š`{to_address}`\n'
                        f'äº¤æ˜“æ—¶é—´ï¼š{formatted_date_time}\n'
                        f'äº¤æ˜“é‡‘é¢ï¼š{amount}USDT\n'
                        f'è´¦æˆ·ä½™é¢ï¼š{round(balance, 2)}TRXï¼Œ{round(usdt_balance, 2)}USDT'
                    )
                    await self.client.send_message(chat_id, message, buttons=keyboard, parse_mode='markdown')
                except Exception as e:
                    logger.error(f"Error sending USDT transaction message to {chat_id}: {e}")

    async def handle_trx_transaction(self, transaction, formatted_date_time, keyboard):
        """å¤„ç†TRXäº¤æ˜“"""
        value = transaction['raw_data']['contract'][0]['parameter']['value']
        from_address = self.tron.address.from_hex(value['owner_address']).decode()
        to_address = self.tron.address.from_hex(value['to_address']).decode()
        amount = value['amount'] / 1000000

        # æ”¯å‡ºç›‘å¬
        if from_address in self.monitored_addresses:
            energy_remaining, bandwidth_remaining, balance, usdt_balance = await self.get_account_info(from_address)
            for chat_id in self.monitored_addresses[from_address]:
                try:
                    message = (
                        f'â*æ”¯å‡ºæé†’ -{amount}TRX*\n'
                        f'ä»˜æ¬¾åœ°å€ï¼š`{from_address}`\n'
                        f'æ”¶æ¬¾åœ°å€ï¼š`{to_address}`\n'
                        f'äº¤æ˜“æ—¶é—´ï¼š{formatted_date_time}\n'
                        f'äº¤æ˜“é‡‘é¢ï¼š{amount}TRX\n'
                        f'è´¦æˆ·ä½™é¢ï¼š{round(balance, 2)}TRXï¼Œ{round(usdt_balance, 2)}USDT'
                    )
                    await self.client.send_message(chat_id, message, buttons=keyboard, parse_mode='markdown')
                except Exception as e:
                    logger.error(f"Error sending TRX transaction message to {chat_id}: {e}")

        # æ”¶æ¬¾ç›‘å¬
        if to_address in self.monitored_addresses:
            energy_remaining, bandwidth_remaining, balance, usdt_balance = await self.get_account_info(to_address)
            for chat_id in self.monitored_addresses[to_address]:
                try:
                    message = (
                        f'âœ…*æ”¶å…¥åˆ°è´¦ +{amount}TRX*\n'
                        f'ä»˜æ¬¾åœ°å€ï¼š`{from_address}`\n'
                        f'æ”¶æ¬¾åœ°å€ï¼š`{to_address}`\n'
                        f'äº¤æ˜“æ—¶é—´ï¼š{formatted_date_time}\n'
                        f'äº¤æ˜“é‡‘é¢ï¼š{amount}TRX\n'
                        f'è´¦æˆ·ä½™é¢ï¼š{round(balance, 2)}TRXï¼Œ{round(usdt_balance, 2)}USDT'
                    )
                    await self.client.send_message(chat_id, message, buttons=keyboard, parse_mode='markdown')
                except Exception as e:
                    logger.error(f"Error sending TRX transaction message to {chat_id}: {e}")

    async def refresh_monitored_addresses(self):
        """å®šæœŸåˆ·æ–°ç›‘å¬åœ°å€åˆ—è¡¨"""
        while True:
            try:
                self.monitored_addresses = self.load_monitored_addresses()
                logger.info("Refreshed monitored addresses")
                await asyncio.sleep(300)  # æ¯5åˆ†é’Ÿåˆ·æ–°ä¸€æ¬¡
            except Exception as e:
                logger.error(f"Error refreshing monitored addresses: {e}")
                await asyncio.sleep(60)

    async def start_monitoring(self):
        """å¼€å§‹ç›‘æ§"""
        await self.client.start(bot_token=self.bot_token)
        logger.info("Wallet monitor started")
        
        # è®¾ç½®å‘½ä»¤å¤„ç†å™¨
        await self.setup_handlers()
        
        # å¯åŠ¨åœ°å€åˆ·æ–°ä»»åŠ¡
        asyncio.create_task(self.refresh_monitored_addresses())
        
        # å¯åŠ¨åŒºå—ç›‘æ§
        while True:
            try:
                current_block = await self.get_latest_block()
                if current_block:
                    await self.monitor_transaction(current_block)
                await asyncio.sleep(3)
            except Exception as e:
                logger.error(f"Error in monitoring loop: {e}")
                await asyncio.sleep(5)

    async def get_latest_block(self):
        """è·å–æœ€æ–°åŒºå—"""
        url = 'https://api.trongrid.io/wallet/getblockbynum'
        headers = {
            'Content-Type': 'application/json',
            'TRON-PRO-API-KEY': self.tron_api_key
        }
        try:
            current_block = self.tron.trx.get_current_block()
            block_number = current_block['block_header']['raw_data']['number']
            
            data = {'num': block_number}
            async with self.client.session.post(url, headers=headers, json=data) as response:
                if response.status == 200:
                    return await response.json()
                else:
                    logger.error(f"Error getting block: {await response.text()}")
                    return None
        except Exception as e:
            logger.error(f"Error getting latest block: {e}")
            return None

    async def add_address(self, chat_id: int, address: str):
        """æ·»åŠ ç›‘å¬åœ°å€"""
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        if not self.tron.isAddress(address):
            return False, "æ— æ•ˆçš„TRXåœ°å€"
        
        if address not in self.monitored_addresses:
            self.monitored_addresses[address] = []
        
        if chat_id in self.monitored_addresses[address]:
            return False, "è¯¥åœ°å€å·²åœ¨ç›‘å¬åˆ—è¡¨ä¸­"
        
        self.monitored_addresses[address].append(chat_id)
        
        with open('ç›‘å¬.txt', 'a', encoding='utf-8') as f:
            f.write(f"{timestamp} - chat_id: {chat_id} - åœ°å€: {address}\n")
        
        return True, "åœ°å€æ·»åŠ æˆåŠŸ"

    async def remove_address(self, chat_id: int, address: str):
        """ç§»é™¤ç›‘å¬åœ°å€"""
        if address not in self.monitored_addresses or chat_id not in self.monitored_addresses[address]:
            return False, "è¯¥åœ°å€ä¸åœ¨ç›‘å¬åˆ—è¡¨ä¸­"
        
        self.monitored_addresses[address].remove(chat_id)
        if not self.monitored_addresses[address]:
            del self.monitored_addresses[address]
        
        # æ›´æ–°æ–‡ä»¶
        with open('ç›‘å¬.txt', 'r', encoding='utf-8') as f:
            lines = f.readlines()
        
        with open('ç›‘å¬.txt', 'w', encoding='utf-8') as f:
            for line in lines:
                if f"chat_id: {chat_id}" not in line or f"åœ°å€: {address}" not in line:
                    f.write(line)
                
        return True, "åœ°å€ç§»é™¤æˆåŠŸ"

    async def reload_config(self):
        """é‡æ–°åŠ è½½é…ç½®"""
        try:
            with open('config.txt', 'r') as f:
                config = dict(line.strip().split('=') for line in f if line.strip())
            
            self.tron_api_key = config['TRON_API_KEY']
            self.control_address = config['control_address']
            self.bot_username = config['bot_id']
            self.customer_service_id = config['CUSTOMER_SERVICE_ID']
            self.group_link = config['group_link']
            
            return True, "é…ç½®é‡è½½æˆåŠŸ"
        except Exception as e:
            logger.error(f"Error reloading config: {e}")
            return False, f"é…ç½®é‡è½½å¤±è´¥: {str(e)}"

    async def setup_handlers(self):
        """è®¾ç½®å‘½ä»¤å¤„ç†å™¨"""
        @self.client.on(events.NewMessage(pattern='/start'))
        async def start_handler(event):
            await event.respond("æ¬¢è¿ä½¿ç”¨é’±åŒ…ç›‘æ§æœºå™¨äºº!\n"
                              "ä½¿ç”¨ /help æŸ¥çœ‹å¸®åŠ©ä¿¡æ¯")

        @self.client.on(events.NewMessage(pattern='/help'))
        async def help_handler(event):
            help_text = (
                "ğŸ“‹ å‘½ä»¤åˆ—è¡¨:\n"
                "/start - å¼€å§‹ä½¿ç”¨\n"
                "/help - æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯\n"
                "å¼€å§‹ç›‘å¬ åœ°å€ - æ·»åŠ ç›‘å¬åœ°å€\n"
                "ç»“æŸç›‘å¬ åœ°å€ - åˆ é™¤ç›‘å¬åœ°å€\n"
                "å·²ç›‘å¬åœ°å€ - æŸ¥çœ‹å½“å‰ç›‘å¬çš„åœ°å€"
            )
            await event.respond(help_text)

        @self.client.on(events.NewMessage(pattern=r'å¼€å§‹ç›‘å¬\s+([A-Za-z0-9]+)'))
        async def add_address_handler(event):
            address = event.pattern_match.group(1)
            chat_id = event.chat_id
            success, message = await self.add_address(chat_id, address)
            await event.respond(message)

        @self.client.on(events.NewMessage(pattern=r'ç»“æŸç›‘å¬\s+([A-Za-z0-9]+)'))
        async def remove_address_handler(event):
            address = event.pattern_match.group(1)
            chat_id = event.chat_id
            success, message = await self.remove_address(chat_id, address)
            await event.respond(message)

        @self.client.on(events.NewMessage(pattern='å·²ç›‘å¬åœ°å€'))
        async def list_addresses_handler(event):
            chat_id = event.chat_id
            addresses = [addr for addr, users in self.monitored_addresses.items() 
                        if chat_id in users]
            if addresses:
                message = "å½“å‰ç›‘å¬çš„åœ°å€:\n" + "\n".join(f"`{addr}`" for addr in addresses)
            else:
                message = "å½“å‰æ²¡æœ‰ç›‘å¬ä»»ä½•åœ°å€"
            await event.respond(message, parse_mode='markdown')

    async def shutdown(self):
        """ä¼˜é›…å…³é—­"""
        logger.info("Shutting down wallet monitor...")
        # å…³é—­ Telegram å®¢æˆ·ç«¯
        await self.client.disconnect()
        logger.info("Wallet monitor shutdown complete")

async def main():
    monitor = None
    try:
        # ä»é…ç½®æ–‡ä»¶è¯»å–é…ç½®
        with open('config.txt', 'r') as f:
            config = dict(line.strip().split('=') for line in f if line.strip())
        
        monitor = WalletMonitor(
            api_id=config['API_ID'],
            api_hash=config['API_HASH'],
            bot_token=config['TOKEN'],
            tron_api_key=config['TRON_API_KEY'],
            control_address=config['control_address'],
            bot_username=config['bot_id'],
            customer_service_id=config['CUSTOMER_SERVICE_ID'],
            group_link=config['group_link']
        )
        
        await monitor.start_monitoring()
    except KeyboardInterrupt:
        logger.info("Received shutdown signal")
    finally:
        if monitor:
            await monitor.shutdown()

if __name__ == '__main__':
    asyncio.run(main()) 
